Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

class CompositeEvent extends EventBase
{
	intent IntentEnum (0..1);
		[synonym FpML value intent]
}

enum IntentEnum
{
	partialTermination,
	correction,
	renegotiation,
	termination,
	earlyTermination
}

class ContractState one of
{
	contract Contract (0..1);
	contractReference TradeIdentifier (0..1);
		[synonym FpML value contractReference]
}

class Event extends CompositeEvent
{
	quantityChange QuantityChange (0..*);
		[synonym FpML value quantityChange]
	partyChange PartyChange (0..*);
	otherTermsChange OtherTermsChange (0..1);
	fee Payment (0..*);
}

choice rule Event_choice
	for Event required choice between
	quantityChange and partyChange and otherTermsChange

class QuantityChange
{
	before ContractState (0..1);
		[synonym FpML value before]
	after ContractState (1..1);
		[synonym FpML value after]
	quantityChange ContractualQuantity (1..1);
		[synonym FpML value quantityChange]
}

class PartyChange
{
	before ContractState (0..1);
	after ContractState (1..1);
	priorParties Party (2..2);
	newParties Party (2..2);
}

class OtherTermsChange
{
	before ContractState (0..1);
	after ContractState (1..1);
}

class Observation
{
	
}

data rule NotionalAmount_Decrease
	when Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule Quantity_Decrease
	when Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule NotionalAmount_Remaining
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Remaining
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule EarlyTermination_InterestPayout_TerminationDate
	when Event -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	then Event -> otherTermsChange ->  before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate >
		Event -> otherTermsChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate 

isEvent PartialTermination
	Event -> quantityChange exists
	and Event -> intent = IntentEnum.partialTermination
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply
	/*
	 * Should we look to adjust the above to provide for the intent not to exist?
	 *      when EventBase -> intent exists 
	 * 		EventBase -> intent = IntentEnum.partialTermination
	 * 			or EventBase -> intent <> IntentEnum.correction
	 *			or EventBase -> intent <> IntentEnum.renegotiation
	 * If yes, we need a defaulting logic
	 */

isEvent EarlyTermination
	Event -> otherTermsChange exists
	and Event -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> earlyTerminationProvision exists
	and EarlyTermination_InterestPayout_TerminationDate apply
		
	