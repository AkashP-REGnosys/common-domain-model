Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractOrContractReference one of
{
	contract Contract (0..*);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ContractOrListedProduct one of
{
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]
	listedProduct ListedProduct (0..1);
		[synonym Rosetta_Workbench value listedProduct]
}

class ContractualProductOrContract one of
{
	execution Execution (0..1);
		[synonym Rosetta_Workbench value execution]
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]	
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event extends EventBase
{
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

abstract class EventBase stereotype preExecution, execution, postExecution <"The event base abstract class.">
{
	messageInformation MessageInformation (0..1);
	timeStamp EventTimeStamp (1..1);
		[synonym Rosetta_Workbench value timeStamp]
	eventIdentifier Identifier (1..1);
		[synonym Rosetta_Workbench value eventIdentifier]
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML value isCorrection 
			set action to ActionEnum.new when False, 
			set action to ActionEnum.correct when True]
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimeStamp stereotype preExecution, execution, postExecution <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML value creationTimestamp pathExpression "header"]
		[synonym Rosetta_Workbench value creationTimestamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML value expiryTimestamp]
}

class ExerciseOutcome extends ContractOrListedProduct one of
{
	payment Payment (0..1);
		[synonym Rosetta_Workbench value payment]
}

class ExercisePrimitive
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Execution
{
	identifier PartyContractIdentifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value partyTradeIdentifier pathExpression "tradeHeader"]	
	tradeDate date (1..1) anchor <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate pathExpression "tradeHeader"]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (2..*);
}

data rule EventTimeStamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimeStamp -> expiryTimestamp exists
	then EventTimeStamp -> expiryTimestamp > EventTimeStamp -> creationTimestamp

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class MessageInformation stereotype preExecution, execution, postExecution <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme "messageIdScheme" <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId pathExpression "messageInformation"]
	sentBy string (0..1) scheme "messageAddressScheme" <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy pathExpression "messageInformation"]
	sentTo string (0..1) scheme "messageAddressScheme" <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo pathExpression "messageInformation"]
	copyTo string (0..*) scheme "messageAddressScheme" <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

/*
 * TODO - The NewTrade primitive should inherit the ContractState class
 * The ingestion doesn't currently supports this inheritance, which needs to be understood/adjusted
 */
class NewTrade one of <"The primitive event to represent a new trade.">
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

data rule NewTrade_party <"The party node associated with a new trade event should be absent when the contract is specified because the party node is part of the Contract class.">
	when Event -> primitive -> newTrade -> contract exists
	then Event -> party is absent

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PartyChange <"The primitive event to represent a change in party(ies) to a contract.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	newTrade NewTrade (0..*) <"The new trade primitive is unbounded to address the case of events such as portfolio compressions, which could result in multiple new trades.">;
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	split SplitPrimitive (0..*);
		[synonym Rosetta_Workbench value split]	
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]
		[synonym Rosetta_Workbench value cashflow]
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	setValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value setValue]
}

class SplitPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before ContractualProductOrContract (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Decrease <"Logic to qualify a decrease in the quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule FullNovation <"Logic to qualify a full novation by the fact that (i) the partyChange primitive is associated with only one resulting contract, (ii) the party and the contract identifier are distinct between the before an after, (iii) the economic terms are unchanged, and (iv) the trade date of the novated contract is equal to the novation date.">
	when Event -> primitive -> partyChange -> after -> contract single exists
	then Event -> primitive -> partyChange -> before -> contract -> party <> Event -> primitive -> partyChange -> after -> contract -> party
	and Event -> primitive -> partyChange -> before -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
	and Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms = Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms
	and Event -> primitive -> partyChange -> after -> contract -> tradeDate = Event -> eventDate

data rule PartialNovation <"Logic to qualify a partial novation by the fact that (i) the partyChange primitive is associated with only multiple resulting contracts, (ii) the party and the contract identifier are distinct across the two after contracts.">
	when Event -> primitive -> partyChange -> after -> contract multiple exists
	then Event -> primitive -> partyChange -> after -> contract -> party <> Event -> primitive -> partyChange -> after -> contract -> party // Need to confirm that this syntax will work programmatically
	and Event -> primitive -> partyChange -> after -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
	/*
	 * Need to add logic to qualify the fact that the economic terms should be unchanged except for the quantity
	 * and the that sum of quantity after = quantity before
	 * 
	 * Need to add logic to qualify the novated portion of the contract (characterised by a party change) have a TD = event date
	 */

data rule NovationFee <"Logic to specify that if a payment is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> payment -> cashflowType = CashflowTypeEnum.novationFee
	then Event -> lineage -> contractReference multiple exists
	and Event -> lineage -> eventReference single exists

data rule Allocation_Rule <"Logic to qualify a partial novation by the fact that a single contractual product results in ">
	when Event -> primitive -> split -> before -> execution -> contractualProduct single exists
	then Event -> primitive -> split -> after -> contract multiple exists
	/*
	 * Need to extend the grammar in order to qualify that before quantity = sum of after quantities
	 */

data rule ContractSplit_Rule <"Logic to qualify a partial novation by the fact that a single contractual product results in ">
	when Event -> primitive -> split -> before -> contractState single exists
	then Event -> primitive -> split -> after -> contract multiple exists
	/*
	 * Need to extend the grammar in order to qualify that before quantity = sum of after quantities
	 */

isEvent NewTradeEvent <"The qualification of a new trade event from the fact that the only primitive is the newTrade.">
	Event -> primitive -> newTrade only exists
	
isEvent PartialTermination <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	if Event -> intent exists 
	then 
		Event -> intent = IntentEnum.partialTermination
		and Event -> primitive -> quantityChange only exists
	else
		Event -> primitive -> quantityChange only exists
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply
	
isEvent FullTermination <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, and (iv) the remaining quantity is null.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.termination
		and Event -> primitive -> quantityChange only exists
	else 
		Event -> primitive -> quantityChange only exists
	and NotionalAmount_Decrease, NotionalAmount_Null apply	
		
isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists 

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, that (ii) there are multiple instances of such observations, and (iii) that there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists
	
isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the payment.">
	( Event -> primitive -> payment
	and Event -> party ) only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent Novation <"The qualification of a novation event from the fact that (i) the only primitive is the partyChange, (ii) the intent is a novation when such intent is specified, (iii) the data rules to qualify a partial or a full novation apply.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.novation
		and Event -> primitive -> partyChange only exists
	else 
		Event -> primitive -> partyChange exists
	and FullNovation or PartialNovation apply

isEvent Allocation <"The qualification of a novation event from the fact that (i) the only primitive is the split, (ii) there is a single contractualProduct before, and (iii) there are multiple contracts after.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.allocation
		and Event -> primitive -> split only exists
	else 
		Event -> primitive -> split only exists
	and Allocation_Rule apply

isEvent ContractSplit <"The qualification of a contract split event from the fact that (i) the only primitive is the split, (ii) there is a single contract before, and (iii) there are multiple contracts after.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.contractSplit
		and Event -> primitive -> split only exists
	else 
		Event -> primitive -> split only exists
	and ContractSplit_Rule apply	
	