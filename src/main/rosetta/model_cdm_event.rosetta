Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

enum IntentEnum
{
	partialTermination
		[synonym Rosetta_Workbench value "partialTermination"],
	correction
		[synonym Rosetta_Workbench value "correction"],
	renegotiation
		[synonym Rosetta_Workbench value "renegotiation"],
	termination
		[synonym Rosetta_Workbench value "termination"],
	earlyTermination
		[synonym Rosetta_Workbench value "earlyTermination"]
}

class ContractState one of
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..1);
		[synonym Rosetta_Workbench value contractReference]
}

class Event extends EventBase
{
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
	otherTermsChange OtherTermsChange (0..1);
	observation ObservationPrimitive (0..*);
	reset ResetPrimitive (0..*);
	fee Payment (0..*);
		[synonym Rosetta_Workbench value fee]
}

choice rule Event_choice
	for Event required choice between
	quantityChange and partyChange and otherTermsChange

class QuantityChange
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	quantityChange ContractualQuantity (1..1);
		[synonym Rosetta_Workbench value quantityChange]
}

class PartyChange
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	priorParties Party (2..2);
	newParties Party (2..2);
}

class OtherTermsChange
{
	before ContractState (0..1);
	after ContractState (1..1);
}

class ObservationPrimitive
{
	curve Curve (1..1);
	observation number (1..1);
	date date (1..1);
	time time (0..1);
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym FpML value side]
	currency CurrencyEnum (0..1);
	informationSource InformationSource (0..1);
		[synonym FpML value informationSource]
}

class ResetPrimitive
{
	contractReference Identifier (1..1);
	observationReference Identifier (1..1);
	curve Curve (1..1);
	date date (1..1);
	setValue number (1..1);
	currency CurrencyEnum (0..1);
	resultingCashflow Money (1..1); // Will need to adjust to support commodity units
}

class Curve one of // This is just a sample of the set of observation objects that should be associated with that class
{
	interestRateCurve FloatingRateIndexEnum (0..1);
	commodityCurve CommodityReferencePriceEnum (0..1);
}


data rule NotionalAmount_Decrease
	when Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule Quantity_Decrease
	when Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule NotionalAmount_Remaining
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Remaining
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null
	when Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule EarlyTermination_InterestPayout_TerminationDate
	when Event -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	then Event -> otherTermsChange ->  before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate >
		Event -> otherTermsChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate

isEvent PartialTermination
	Event -> quantityChange exists
	and Event -> intent = IntentEnum.partialTermination
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

isEvent EarlyTermination
	Event -> otherTermsChange exists
	and Event -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> earlyTerminationProvision exists
	and EarlyTermination_InterestPayout_TerminationDate apply

/*
 * Consider adding to the grammar the 'only exists' qualifier, to enhance legibility & maintainability 
 */
		
isEvent Observation
	Event -> observation exists
	and Event -> party is absent
	and Event -> intent is absent
	and Event -> otherTermsChange is absent
	and Event -> quantityChange is absent
	and Event -> partyChange is absent
	and Event -> reset is absent
	and Event -> fee is absent

isEvent Reset
	Event -> reset exists
	and Event -> party exists
	and Event -> observation is absent
	and Event -> otherTermsChange is absent
	and Event -> quantityChange is absent
	and Event -> partyChange is absent
	and Event -> fee is absent
	
isEvent Payment
	Event -> fee exists
	and Event -> party exists
	and Event -> observation is absent
	and Event -> otherTermsChange is absent
	and Event -> quantityChange is absent
	and Event -> partyChange is absent
