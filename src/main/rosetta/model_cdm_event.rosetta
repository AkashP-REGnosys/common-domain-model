Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

enum IntentEnum
{
	partialTermination
		[synonym Rosetta_Workbench value "partialTermination"],
	correction
		[synonym Rosetta_Workbench value "correction"],
	renegotiation
		[synonym Rosetta_Workbench value "renegotiation"],
	termination
		[synonym Rosetta_Workbench value "termination"],
	earlyTermination
		[synonym Rosetta_Workbench value "earlyTermination"]
}

/*
 * CDM testing artefacts
 */

class EventTestBundle <"Class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractState one of
{
	contract Contract (0..1);
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event extends EventBase
{
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class NewTrade extends ContractState one of <"The primitive event to represent a new trade.">
{
}

class ObservationPrimitive <"The primitive event to represent an observation. The reason for the Primitive suffix is not to conflict with the qualified observation event.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
}

class PartyChange <"The primitive event to represent a change in the parties to a contract.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	priorParties Party (2..2);
		[synonym Rosetta_Workbench value priorParties]
	newParties Party (2..2);
		[synonym Rosetta_Workbench value newParties]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	/*
	 * Alternative to representing a new trade as a QuantityChange would be to have a dedicated new primitive
	 * One of the implied benefit would be to facilitate the further adjustments once we expand the CDM scope
	 * to include pre-execution events 
	 */
	newTrade NewTrade (0..*);
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]	
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive <"The primitive event to represent a reset. The reason for the Primitive suffix is not to conflict with the qualified reset event.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	setValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value setValue]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule Quantity_Decrease <"Logic to qualify an increase in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule EarlyTermination_InterestPayout_TerminationDate <"Logic to  qualify a change to an earlier termination date as a result of an other terms change primitive event.">
	when Event -> primitive -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	then Event -> primitive -> otherTermsChange ->  before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate >
		Event -> primitive -> otherTermsChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate

isEvent NewTradeEvent <"The qualification of a new trade event.">
	Event -> primitive -> quantityChange -> after -> contract exists
	and Event -> primitive -> quantityChange -> before is absent
	and Event -> primitive -> quantityChange -> change -> notionalAmount -> amount > 0b
		or Event -> primitive -> quantityChange -> change -> quantity -> amount > 0b
		or Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepSchedule -> initialValue > 0b
		or Event -> primitive -> quantityChange -> change -> fxLinkedNotional -> initialValue > 0b

isEvent NewTradeEvent_alternative
	Event -> primitive -> newTrade exists
	
isEvent PartialTermination <"The qualification of a partial termination event.">
	Event -> primitive -> quantityChange exists
	and Event -> intent = IntentEnum.partialTermination
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

/*
 * Do we also need the intent qualification in the case of a full termination?
 */
isEvent FullTermination <"The qualification of an full termination event.">
	Event -> primitive -> quantityChange exists
	and NotionalAmount_Decrease, NotionalAmount_Null apply
		
isEvent Observation <"The qualification of an observation event.">
	Event -> primitive -> observation only exists 

isEvent DerivedObservation <"The qualification of a derived observation event.">
	(Event -> primitive -> observation 
	and Event -> functionCall) only exists

isEvent Reset <"The qualification of a reset event.">
	Event -> primitive -> reset only exists
	
isEvent Payment <"The qualification of a payment event.">
	( Event -> primitive -> payment
	and Event -> party ) only exists
