namespace "org.isda.cdm"

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before Execution (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractOrContractReference one of
{
	contract Contract (0..*);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractReference (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ContractOrListedProduct one of
{
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]
	listedProduct ListedProduct (0..1);
		[synonym Rosetta_Workbench value listedProduct]
}

class ContractReference extends ContractIdentifier
{
	state ContractStateEnum (0..1) <"The state qualification of a contractual product.">;
		[synonym Rosetta_Workbench value state]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event extends EventBase
{
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

abstract class EventBase stereotype preExecution, execution, postExecution <"The event base abstract class.">
{
	messageInformation MessageInformation (0..1);
	timestamp EventTimestamp (1..1);
		[synonym Rosetta_Workbench value timeStamp]
	eventIdentifier Identifier (1..1);
		[synonym Rosetta_Workbench value eventIdentifier]
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML value isCorrection 
			set action to ActionEnum.new when False, 
			set action to ActionEnum.correct when True]
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp stereotype preExecution, execution, postExecution <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML value creationTimeStamp pathExpression "header"]
		[synonym Rosetta_Workbench value creationTimeStamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML value expiryTimestamp]
}

class ExerciseOutcome extends ContractOrListedProduct one of
{
	payment Payment (0..1);
		[synonym Rosetta_Workbench value payment]
}

class ExercisePrimitive
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Execution
{
	identifier PartyContractIdentifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value partyTradeIdentifier pathExpression "tradeHeader"]	
	tradeDate date (1..1) anchor <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate pathExpression "tradeHeader"]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (2..*);
}

data rule EventTimestamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimestamp -> expiryTimestamp exists
	then EventTimestamp -> expiryTimestamp > EventTimestamp -> creationTimestamp

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class MessageInformation stereotype preExecution, execution, postExecution <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme "messageIdScheme" <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId pathExpression "messageInformation"]
	sentBy string (0..1) scheme "messageAddressScheme" <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy pathExpression "messageInformation"]
	sentTo string (0..1) scheme "messageAddressScheme" <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo pathExpression "messageInformation"]
	copyTo string (0..*) scheme "messageAddressScheme" <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

/*
 * TODO - The NewTrade primitive should inherit the ContractState class
 * The ingestion doesn't currently supports this inheritance, which needs to be understood/adjusted
 */
class NewTrade one of <"The primitive event to represent a new trade.">
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

data rule NewTrade_party <"The party node associated with a new trade event should be absent when the contract is specified because the party node is part of the Contract class.">
	when Event -> primitive -> newTrade -> contract exists
	then Event -> party is absent

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PartyChange <"The primitive event to represent a change in party(ies) to a contract.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	newTrade NewTrade (0..*) <"The new trade primitive is unbounded to address the case of events such as portfolio compressions, which could result in multiple new trades.">;
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]	
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]
		[synonym Rosetta_Workbench value cashflow]
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	setValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value setValue]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Decrease <"Logic to qualify a decrease in the quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule ContractReference_Terminated <"Logic to qualify that a contract reference has been terminated.">
	when Event -> primitive -> quantityChange -> after -> contractReference exists
	then Event -> primitive -> quantityChange -> after -> contractReference -> state = ContractStateEnum.terminated

data rule Contract_Terminated <"Logic to qualify that a contract has been terminated.">
	when Event -> primitive -> quantityChange -> after -> contract exists
	then Event -> primitive -> quantityChange -> after -> contract -> state = ContractStateEnum.terminated

/*
 * TODO - Comment from the CDM group is that while the equality in the economic terms between the prior contract and the novated contract is appropriate in principle, we should further look into potential edge cases. The case that was discussed relates to the fact that a novation could imply that a swaption that was negotiated under MCA terms might move to Matrix terms following the novation, which would result in a change of the exercise time. It was however noted that, if the contract had been properly drafted, such exercise time would not be specified as part of the trade because it would be implied by such reference terms, and hence would not result in economic differences between those contracts.
 * 
 */
data rule FullNovation_Contract <"Logic to qualify a full novation when the resulting contract is specified (instead of being referenced) by the fact that (i) there is only one resulting contract, (ii) the party and the contract identifier are distinct between the before an after, (iii) the economic terms are unchanged, (iv) the trade date of the novated contract is equal to the novation date, and (v) the resulting contract state is 'novated'.">
	when Event -> primitive -> partyChange -> after -> contract single exists
	then Event -> primitive -> partyChange -> before -> contract -> party <> Event -> primitive -> partyChange -> after -> contract -> party
	and Event -> primitive -> partyChange -> before -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
	and Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms = Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms
	and Event -> primitive -> partyChange -> after -> contract -> tradeDate -> date = Event -> eventDate
	and Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate = Event -> effectiveDate
	and Event -> primitive -> partyChange -> after -> contract -> state = ContractStateEnum.novated

data rule Novation_EffectiveDate <"The requirement that the effective date of the novated trade be equal to the event effective date implies that the novation event should always have an associated effective date (which is optional from a data cardinality standpoint).">
	when Event -> primitive -> partyChange exists
	then Event -> effectiveDate exists

data rule FullNovation_ContractReference <"Logic to qualify a full novation when the resulting contract is referenced (instead of being specified) by the fact that (i) there is only one resulting contract and (ii) the resulting contract state is 'novated'.">
	when Event -> primitive -> partyChange -> after -> contractReference single exists
	then Event -> primitive -> partyChange -> after -> contractReference -> state = ContractStateEnum.novated

data rule PartialNovation <"Logic to qualify a partial novation by the fact that (i) the partyChange primitive is associated with only multiple resulting contracts, (ii) the party and the contract identifier are distinct across the two after contracts.">
	when Event -> primitive -> partyChange -> after -> contract multiple exists
	then Event -> primitive -> partyChange -> after -> contract -> party <> Event -> primitive -> partyChange -> after -> contract -> party // Need to confirm that this syntax will work programmatically
	and Event -> primitive -> partyChange -> after -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
	/*
	 * Need to add logic to qualify the fact that the economic terms should be unchanged except for the quantity
	 * and the that sum of quantity after = quantity before
	 * 
	 * Need to add logic to qualify the novated portion of the contract (characterised by a party change) have a TD = event date & EF = event effective date
	 */

data rule NovationFee <"Logic to specify that if a payment is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> payment -> cashflowType = CashflowTypeEnum.novationFee
	then Event -> lineage -> contractReference multiple exists
	and Event -> lineage -> eventReference single exists

data rule Allocation_ContractReference <"Logic to qualify an allocation that references the allocated contracts (instead of explicitly stating those) from the fact that (i) there are multiple such references and (ii) the resulting state is 'allocated'.">
	when Event -> primitive -> allocation -> after -> contractReference exists
	then Event -> primitive -> allocation -> after -> contractReference multiple exists
	and Event -> primitive -> allocation -> after -> contractReference -> state = ContractStateEnum.allocated
	/*
	 * Need to extend the grammar in order to qualify that before quantity = sum of after quantities
	 */
 
 data rule Allocation_Contract <"Logic to qualify an allocation that specifies the allocated contracts (instead of referencing those) from the fact that (i) there are multiple such references and (ii) the resulting state is 'allocated'.">
	when Event -> primitive -> allocation -> after -> contract exists
	then Event -> primitive -> allocation -> after -> contract multiple exists
	and Event -> primitive -> allocation -> after -> contract -> state = ContractStateEnum.allocated
	/*
	 * Need to extend the grammar in order to qualify that before quantity = sum of after quantities
	 */
 
isEvent Allocation <"The qualification of a novation event from the fact that (i) the only primitive is the split, (ii) the intent is an allocation when such intent is specified, (iii) there is a single contractualProduct before, and (iv) there are multiple contracts after.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.allocation
		and Event -> primitive -> allocation only exists
	else 
		Event -> primitive -> allocation only exists
	and Allocation_ContractReference or Allocation_Contract apply

isEvent Compression <"The qualification of a compression event from the fact that (i) the quantity change primitive exists and (ii) the intent is a compression when such intent is specified.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.compression
		and Event -> primitive -> quantityChange exists
	else 
		Event -> primitive -> quantityChange exists

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, that (ii) there are multiple instances of such observations, and (iii) that there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists
	
isEvent FullTermination <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, (iv) the remaining quantity is null, and (v) the contract state has the value 'terminated'.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.termination
		and Event -> primitive -> quantityChange only exists
	else 
		Event -> primitive -> quantityChange only exists
	and NotionalAmount_Decrease, NotionalAmount_Null, Contract_Terminated or ContractReference_Terminated apply
	
isEvent PartialTermination <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	if Event -> intent exists 
	then 
		Event -> intent = IntentEnum.partialTermination
		and Event -> primitive -> quantityChange only exists
	else
		Event -> primitive -> quantityChange only exists
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

isEvent NewTradeEvent <"The qualification of a new trade event from the fact that the only primitive is the newTrade.">
	Event -> primitive -> newTrade only exists

isEvent Novation <"The qualification of a novation event from the fact that (i) the only primitive is the partyChange, (ii) the intent is a novation when such intent is specified, (iii) the data rules to qualify a partial or a full novation apply.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.novation
		and Event -> primitive -> partyChange only exists
	else 
		Event -> primitive -> partyChange only exists
	and Novation_EffectiveDate, FullNovation_Contract or FullNovation_ContractReference or PartialNovation apply
		
isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists 

isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the payment.">
	( Event -> primitive -> payment
	and Event -> party ) only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists
