Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractOrContractReference one of
{
	contract Contract (0..1);
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ContractOrListedProduct one of
{
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]
	listedProduct ListedProduct (0..1);
		[synonym Rosetta_Workbench value listedProduct]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event extends EventBase
{
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

abstract class EventBase stereotype preExecution, execution, postExecution <"The event base abstract class.">
{
	messageInformation MessageInformation (0..1);
	timeStamp EventTimeStamp (1..1);
		[synonym Rosetta_Workbench value timeStamp]
	eventIdentifier Identifier (1..1);
		[synonym Rosetta_Workbench value eventIdentifier]
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML value isCorrection 
			set action to ActionEnum.new when False, 
			set action to ActionEnum.correct when True]
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimeStamp stereotype preExecution, execution, postExecution <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML value creationTimestamp pathExpression "header"]
		[synonym Rosetta_Workbench value creationTimestamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML value expiryTimestamp]
}

class ExerciseOutcome extends ContractOrListedProduct one of
{
	cashflow Payment (0..1);
}

class ExercisePrimitive
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

data rule EventTimeStamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimeStamp -> expiryTimestamp exists
	then EventTimeStamp -> expiryTimestamp > EventTimeStamp -> creationTimestamp

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class MessageInformation stereotype preExecution, execution, postExecution <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme "messageIdScheme" <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId pathExpression "messageInformation"]
	sentBy string (0..1) scheme "messageAddressScheme" <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy pathExpression "messageInformation"]
	sentTo string (0..1) scheme "messageAddressScheme" <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo pathExpression "messageInformation"]
	copyTo string (0..*) scheme "messageAddressScheme" <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

/*
 * TODO - The NewTrade primitive should inherit the ContractState class
 * The ingestion doesn't currently supports this inheritance, which needs to be understood/adjusted
 */
class NewTrade one of <"The primitive event to represent a new trade.">
{
	contract Contract (0..1);
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

data rule NewTrade_party <"The party node associated with a new trade event should be absent when the contract is specified because the party node is part of the Contract class.">
	when Event -> primitive -> newTrade -> contract exists
	then Event -> party is absent

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PartyChange <"The primitive event to represent a change in the parties to a contract.">
{
	before ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	priorParties Party (2..2);
		[synonym Rosetta_Workbench value priorParties]
	newParties Party (2..2);
		[synonym Rosetta_Workbench value newParties]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	newTrade NewTrade (0..*) <"The new trade primitive is unbounded to address the case of events such as portfolio compressions, which could result in multiple new trades.">;
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]	
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive <"The primitive event to represent a reset. The reason for the Primitive suffix is not to conflict with the isEvent Reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	setValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value setValue]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule Quantity_Decrease <"Logic to qualify an increase in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule EarlyTermination_InterestPayout_TerminationDate <"Logic to  qualify a change to an earlier termination date as a result of an other terms change primitive event.">
	when Event -> primitive -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	then Event -> primitive -> otherTermsChange ->  before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate >
		Event -> primitive -> otherTermsChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate

isEvent NewTradeEvent <"The qualification of a new trade event.">
	Event -> primitive -> newTrade exists
	
isEvent PartialTermination <"The qualification of a partial termination event.">
	Event -> primitive -> quantityChange exists
	and Event -> intent = IntentEnum.partialTermination
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

/*
 * Do we also need the intent qualification in the case of a full termination?
 */
isEvent FullTermination <"The qualification of an full termination event.">
	Event -> primitive -> quantityChange exists
	and NotionalAmount_Decrease, NotionalAmount_Null apply
		
isEvent Observation <"The qualification of an observation event.">
	Event -> primitive -> observation only exists 

isEvent DerivedObservation <"The qualification of a derived observation event.">
	(Event -> primitive -> observation 
	and Event -> functionCall) only exists

isEvent Reset <"The qualification of a reset event.">
	Event -> primitive -> reset only exists
	
isEvent Payment <"The qualification of a payment event.">
	( Event -> primitive -> payment
	and Event -> party ) only exists


	
/*******************************
 * New Proposed Event Approach
 */

class TransactionEvent extends EventBase <"A transaction event involves 2 or more parties, can have an intent and has a before/after contract state">
{
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	before Before (1..1);
		[synonym Rosetta_Workbench value before]
	after After (1..1);
		[synonym Rosetta_Workbench value after]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

class MarketEvent extends EventBase <"A market event doesn't involve parties, intent nor contract reference.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

class Before one of
{
	contractState ContractOrContractReference (0..*);
		[synonym Rosetta_Workbench value contractState]
	marketEvent MarketEvent (0..*);
		[synonym Rosetta_Workbench value marketEvent]
}

class After
{
	contractOrListedProduct ContractOrListedProduct (0..*);
	cashflow Payment (0..*);
}

isEvent CashExercise <"The qualification of a physical exercise event: the before contract state is an option, the after state is a cashflow with no option.">
	TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout exists
	and TransactionEvent -> after -> cashflow exists
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout is absent

isEvent PhysicalExercise <"The qualification of a physical exercise event: the before contract state is an option, the after state is a product that corresponds to the option underlyer with no option.">
	TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout exists
	and ( TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct =
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlyer -> contractualProduct )
		or ( TransactionEvent -> after -> contractOrListedProduct -> listedProduct =
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlyer -> listedProduct )
	// TODO - Provide the ability to compute this equality in the case where the contractReference is specified, instead of the actual contract
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout is absent

isEvent CashPartialExercise <"The qualification of a physical exercise event: the before contract state is an option, the after state is a cashflow with an option which quantity is less than the before state.">
	TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout exists
	and TransactionEvent -> after -> cashflow exists
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount > 0
	// TODO - Add an alias to abstract the various ways in which the quantity can be expressed: actual quantity, schedule, ...
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity <
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity

isEvent PhysicalPartialExercise <"The qualification of a physical exercise event: the before contract state is an option, the after state is a product that corresponds to the option underlyer with an option which quantity is less than the before state.">
	TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout exists
	and ( TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct =
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlyer -> contractualProduct )
		or ( TransactionEvent -> after -> contractOrListedProduct -> listedProduct =
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlyer -> listedProduct )
	// TODO - Enhance the grammar to provide the ability to exclude the quantity from this equality statement
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount > 0
	// TODO - Add an alias to abstract the various ways in which the quantity can be expressed: actual quantity, schedule, ...
	and TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity <
		TransactionEvent -> before -> contractState -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity

isEvent Allocation <"The qualification of an allocation event: the before state has one contract, while the after state has several contracts.">
	TransactionEvent -> before -> contractState only exists
	and TransactionEvent -> after -> contractOrListedProduct -> contractState exists // Grammar adjustment to express plurality
	and TransactionEvent -> intent = IntentEnum.allocation
	// TODO - Enhance the grammar to have a syntax to qualify that the sum of the notionals/quantities on the allocated contracts is equal to the before contract
	
isEvent PortfolioCompression <"The qualification of a portfolio compression event: the before state has several contracts, and the after state has either contract(s) with cashflows or only cashflows.">
	TransactionEvent -> intent = IntentEnum.portfolioCompression
	and TransactionEvent -> before -> contractState exists // Grammar adjustment to express plurality
	and ( ( TransactionEvent -> after -> contractOrListedProduct -> contractState and TransactionEvent -> after -> cashflow exists )
		or TransactionEvent -> after -> cashflow exists )
	// TODO - Possibly, enhance the grammar to qualify that the number of contracts before > number of contracts after

isEvent Novation <"The qualification of a novation event: the contract before has different parties that the contract after.">
	TransactionEvent -> before -> contractState -> contract -> party <>
	TransactionEvent -> after -> contractOrListedProduct -> contractState -> contract -> party
	// TODO - Need to refine the syntax to qualify that one of the parties is the same, while the other one has changed.
	and TransactionEvent -> after -> cashflow exists // Comparing the payer/receiver parties to the contract parties would be tricky because not using the same constructs 
