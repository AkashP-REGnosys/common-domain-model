namespace "org.isda.cdm"

class AllocationOutcome extends ContractOrContractReference <"Class to specify the allocated contracts or contract references, alongside the state qualification of the execution.">
{
	execution ExecutionReference (1..1);
}

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before Execution (1..1);
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction string (1..1);
	amount number (1..1);
	currency CurrencyEnum (0..1);
}

class ContractOrContractReference one of
{
	contract Contract (0..*);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractReference (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ContractOrListedProduct rosettaKey one of
{
	contractState ContractOrContractReference (0..1);
		[synonym Rosetta_Workbench value contractState]
	listedProduct ListedProduct (0..1);
		[synonym Rosetta_Workbench value listedProduct]
}

class ContractReference extends ContractIdentifier
{
	state StateEnum (0..1) <"The state qualification of a contractual product.">;
		[synonym Rosetta_Workbench value state]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class Event rosettaKey
{
	messageInformation MessageInformation (0..1);
	timestamp EventTimestamp (1..1);
		[synonym Rosetta_Workbench value timestamp]
	eventIdentifier Identifier (1..1);
		[synonym Rosetta_Workbench value eventIdentifier]
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML value isCorrection 
			set action to ActionEnum.new when False, 
			set action to ActionEnum.correct when True]
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, exercise events), reset values, ...">;
}

class EventEffect <"The set of operational and positional effects associated with a lifecycle event.">
{
	timestamp dateTime (1..1) <"The date and time on which the contract effect is taking place.">;
		[synonym Rosetta_Workbench value creationTimestamp pathExpression "timestamp"]
		// Consider new syntax like copy from Event -> timestamp -> creationTimestamp
	referenceContract Contract (1..1) rosettaKey <"A pointer to the contract to which the contract effect(s) apply.">;
	referenceEvent Event (1..1) rosettaKey <"A pointer to the contract to which the contract effect(s) apply.">;
	product ContractOrListedProduct (0..*) rosettaKey <"A pointer to the products effect(s), an example of such being the outcome of an option physical exercise.">;
	payment Payment (0..*) rosettaKey <"A pointer to the payment effect(s).">;
	reset ResetPrimitive (0..*) rosettaKey <"A pointer to the reset effect(s).">;
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML value creationTimestamp pathExpression "header"]
		[synonym Rosetta_Workbench value creationTimestamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML value expiryTimestamp]
}

class ExecutionReference
{
	executionReference Identifier (1..1);
		[synonym Rosetta_Workbench value executionReference]
	state StateEnum (1..1);
		[synonym Rosetta_Workbench value state]
}

class ExerciseOutcome extends ContractOrListedProduct one of
{
	payment Payment (0..1);
		[synonym Rosetta_Workbench value payment]
}

class ExercisePrimitive
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Execution
{
	identifier PartyContractIdentifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value partyTradeIdentifier pathExpression "tradeHeader"]	
	tradeDate date (1..1) anchor <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate pathExpression "tradeHeader"]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (2..*);
}

data rule EventTimestamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimestamp -> expiryTimestamp exists
	then EventTimestamp -> expiryTimestamp > EventTimestamp -> creationTimestamp

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage
{
	contractReference Identifier (0..*) scheme "correlationIdScheme";
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class MessageInformation <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme "messageIdScheme" <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId pathExpression "messageInformation"]
	sentBy string (0..1) scheme "messageAddressScheme" <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy pathExpression "messageInformation"]
	sentTo string (0..1) scheme "messageAddressScheme" <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo pathExpression "messageInformation"]
	copyTo string (0..*) scheme "messageAddressScheme" <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

/*
 * TODO - The NewTrade primitive should inherit the ContractState class
 * The ingestion doesn't currently supports this inheritance, which needs to be understood/adjusted
 */
class NewTrade one of <"The primitive event to represent a new trade.">
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
}

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PartyChange <"The primitive event to represent a change in party(ies) to a contract.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	newTrade NewTrade (0..*) <"The new trade primitive is unbounded to address the case of events such as portfolio compressions, which could result in multiple new trades.">;
		[synonym Rosetta_Workbench value newTrade]
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]	
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]
		[synonym Rosetta_Workbench value cashflow]
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractOrContractReference (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive rosettaKey <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	setValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value setValue]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme "timezoneLocationScheme" <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Decrease <"Logic to qualify a decrease in the quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

/*
 * TODO - Comment from the CDM group is that while the equality in the economic terms between the prior contract and the novated contract is appropriate in principle, 
 * we should further look into potential edge cases. The case that was discussed relates to the fact that a novation could imply that a swaption that was negotiated under MCA terms might move to Matrix terms following the novation, which would result in a change of the exercise time. 
 * It was however noted that, if the contract had been properly drafted, such exercise time would not be specified as part of the trade because it would be implied by such reference terms, and hence would not result in economic differences between those contracts.
 * 
 * TODO - Enable the ability for data rules to reference aliases
 * 
 */
data rule FullNovation_Contract <"Logic to qualify a full novation when the resulting contract is specified (instead of being referenced) by the fact that (i) there are two resulting contracts, (ii) the party and the contract identifier are distinct between the before an after, (iii) the economic terms are unchanged, (iv) the trade date of the new contract is equal to the novation date, (v) the effective date of the new contract is equal to the event effective date, and (vi) the resulting contract state is 'novated'.">
//	Event -> intent = IntentEnum.novation when present 
//	and for Event -> primitive -> partyChange -> after -> contract -> contractIdentifier = Event -> primitive -> partyChange -> before -> contract -> contractIdentifier
//		Event -> primitive -> partyChange -> after -> contract -> 
	
	when Event -> primitive -> partyChange -> after -> contract count = 2
		or ( Event -> primitive -> partyChange -> after -> contract single exists
			and Event -> primitive -> partyChange -> after -> contractReference single exists )
	then Event -> primitive -> partyChange -> before -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
//	and originalContractParties <> newContractParties
	and Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms = Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms
	and Event -> primitive -> partyChange -> after -> contract -> tradeDate -> date = Event -> eventDate
	and Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate = Event -> effectiveDate
	and Event -> primitive -> partyChange -> before -> contract -> contractIdentifier = Event -> primitive -> partyChange -> before -> contract -> contractIdentifier
		
	/*
	 * Needs to refine the syntax to state that the contract reference which contractId = the one before has a novated state
	 */

alias originalContractParties
	( Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference)
	or ( Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerPartyReference
		and Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> receiverPartyReference )
	or ( Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> partyChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)
	
alias newContractParties
	( Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference)
	or ( Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerPartyReference
		and Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> receiverPartyReference )
	or ( Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> partyChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)	

data rule Novation_EffectiveDate <"The requirement that the effective date of the novated trade be equal to the event effective date implies that the novation event should always have an associated effective date (which is optional from a data cardinality standpoint).">
	when Event -> primitive -> partyChange exists
	then Event -> effectiveDate exists

/*
 * TODO - Same as noted for ContractReference_Terminated.  That rule is actually useless as far as the model is concerned.  3 alternatives:
 * - Remove the ability to specify the after state by contract reference
 * - Specify the contract state alongside the contract reference
 * - Keep the ability to specify the contract state, but accept the fact that no validation logic can apply at the CDM level
 */
data rule FullNovation_ContractReference <"Logic to qualify a full novation when the resulting contract is referenced (instead of being specified) by the fact that (i) there is only one resulting contract and (ii) the prior contract state is 'novated'.">
	when Event -> primitive -> partyChange -> after -> contractReference single exists
	then Event -> primitive -> partyChange -> after -> contractReference -> state = StateEnum.novated

data rule PartialNovation <"Logic to qualify a partial novation by the fact that (i) the partyChange primitive is associated with only multiple resulting contracts, (ii) the party and the contract identifier are distinct across the two after contracts.">
	when Event -> primitive -> partyChange -> after -> contract multiple exists
	then Event -> primitive -> partyChange -> after -> contract -> party <> Event -> primitive -> partyChange -> after -> contract -> party // Need to confirm that this syntax will work programmatically
	and Event -> primitive -> partyChange -> after -> contract -> contractIdentifier <> Event -> primitive -> partyChange -> after -> contract -> contractIdentifier
	/*
	 * Need to add logic to qualify the fact that the economic terms should be unchanged except for the quantity
	 * and the that sum of quantity after = quantity before
	 * 
	 * Need to add logic to qualify the novated portion of the contract (characterised by a party change) have a TD = event date & EF = event effective date
	 */

data rule NovationFee <"Logic to specify that if a payment is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> payment -> cashflowType = CashflowTypeEnum.novationFee
	then Event -> lineage -> contractReference multiple exists
	and Event -> lineage -> eventReference single exists

/*
 * TODO - As a way to avoid a repeat of the same clauses to handle the intent / no intent, look to adjust the isEvent syntax as:
 * Event -> intent = IntentEnum.compression when present 
 * and clause 1
 * and clause 2
 * ....
 */

isEvent Allocation <"The qualification of allocation event from the fact that (i) the only primitive is the allocation, (ii) the intent is an allocation when such intent is specified, (iii) there is a single contractualProduct before. Note: it is accepted that an allocation can result in a single contract.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.allocation
		and Event -> primitive -> allocation only exists
	else 
		Event -> primitive -> allocation only exists
	/*
	 * TODO - before quantity = sum of after quantities
	 * Could be:
	 * and quantityBeforeAllocation = sum quantityAfterAllocation
	 * Note: is there a way to make it workable for the references?  If challenging, we could look to check whether such references are used in practice,
	 * or specify that the validation logic is not applicable to such cases. 
	 */

alias quantityBeforeAllocation <"The alias to represent the quantity or notional amount associated to a pre-allocation contractual product in terms of number of units (i.e. ignoring the currency or units denomination) or reference to such quantity/notional.">
	Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalReference
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> constantNotionalScheduleReference
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalReference
	or Event -> primitive -> allocation -> before -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterAllocation <"The alias to represent the quantity or notional amount associated allocated contract(s) in terms of number of units (i.e. ignoring the currency or units denomination) or reference to such quantity/notional.">
	Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalReference
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> constantNotionalScheduleReference
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalReference
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount


/*
 * TODO - We should look to remove the ability to specify the after by contractReference, as the qualification logic will need to navigate the terms of the contract
 */

isEvent Compression <"The qualification of a compression event from the fact that (i) the quantity change primitive exists, (ii) the intent is a compression when such intent is specified, (iii) there are multiple contracts (or contract references) specified in the before state and (iv) the number of contracts in the after state that are not terminated is less than the number of contracts in the before state.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.compression
		and Event -> primitive -> quantityChange exists
//		and contractBeforeQuantityChange multiple exists
	else 
		Event -> primitive -> quantityChange exists
//		and contractBeforeQuantityChange multiple exists
		/*
		 * TODO Add syntax logic to specify that the number of contracts after which state is <> terminated is less than number of contracts before
		 * could be:
		 * and contractBeforeQuantityChange count > Event -> primitive -> quantityChange -> after -> contract -> state <> StateEnum.terminated count
		 * or:
		 * and contractBeforeQuantityChange count > contractAfterQuantityChange -> state <> StateEnum.terminated count
		 */

alias contractBeforeQuantityChange
	Event -> primitive -> quantityChange -> before -> contract
	or Event -> primitive -> quantityChange -> before -> contractReference

alias contractAfterQuantityChange
	Event -> primitive -> quantityChange -> after -> contract
	or Event -> primitive -> quantityChange -> before -> contractReference

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, that (ii) there are multiple instances of such observations, and (iii) that there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is an exercise when such intent is specified.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.exercise
		and Event -> primitive -> exercise only exists
	else 
		Event -> primitive -> exercise only exists
	
isEvent Termination <"The qualification of a termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, (iv) the remaining quantity is null, and (v) the contract state has the value 'terminated'.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.termination
		and Event -> primitive -> quantityChange only exists
	else 
		Event -> primitive -> quantityChange only exists
	and NotionalAmount_Decrease, NotionalAmount_Null apply

//data rule ContractState_Terminated <"Logic to qualify that a contract reference has been terminated.">
//	when alias contractAfterQuantityChange exists
//	then alias -> state = StateEnum.terminated
	
isEvent PartialTermination <"The qualification of a full termination event from the fact that (i) the only primitive is the quantityChange, (ii) the intent is a full termination when such intent is specified, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	if Event -> intent exists 
	then 
		Event -> intent = IntentEnum.partialTermination
		and ( Event -> primitive -> quantityChange only exists
			or ( Event -> primitive -> quantityChange and Event -> primitive -> payment ) only exists )
		and Event -> primitive -> quantityChange single exists
	else
		( Event -> primitive -> quantityChange only exists
			or ( Event -> primitive -> quantityChange and Event -> primitive -> payment ) only exists )
		and Event -> primitive -> quantityChange single exists
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

isEvent NewTradeEvent <"The qualification of a new trade event from the fact that the only primitive is the newTrade.">
	Event -> primitive -> newTrade only exists

isEvent Novation <"The qualification of a novation event from the fact that (i) the only primitive is the partyChange, (ii) the intent is a novation when such intent is specified, (iii) the data rules to qualify a partial or a full novation apply.">
	if Event -> intent exists
	then 
		Event -> intent = IntentEnum.novation
		and Event -> primitive -> partyChange only exists
	else 
		Event -> primitive -> partyChange only exists
	and Novation_EffectiveDate, FullNovation_Contract or FullNovation_ContractReference, PartialNovation apply
		
isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists 

isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the payment.">
	( Event -> primitive -> payment
	and Event -> party ) only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists
