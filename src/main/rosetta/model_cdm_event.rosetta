Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

enum IntentEnum
{
	partialTermination
		[synonym Rosetta_Workbench value "partialTermination"],
	correction
		[synonym Rosetta_Workbench value "correction"],
	renegotiation
		[synonym Rosetta_Workbench value "renegotiation"],
	termination
		[synonym Rosetta_Workbench value "termination"],
	earlyTermination
		[synonym Rosetta_Workbench value "earlyTermination"]
}

class ContractState one of
{
	contract Contract (0..1);
		[synonym Rosetta_Workbench value contract]
	contractReference ContractIdentifier (0..1);
		[synonym Rosetta_Workbench value contractReference]
}

class Event extends EventBase
{
	party Party (0..*);
		[synonym Rosetta_Workbench value party]
		/*
 * TO CONFIRM WITH CDM GROUP
 * New generic lineage construct + primitive class to make rule logic associated with primitives more legible and scalable.
 */
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1);
		[synonym Rosetta_Workbench value functionCall]
}

class Lineage
{
	contractReference Identifier (0..*);
		[synonym Rosetta_Workbench value contractReference]
	eventReference Identifier (0..*);
		[synonym Rosetta_Workbench value eventReference]
}

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	quantityChange QuantityChange (0..*);
		[synonym Rosetta_Workbench value quantityChange]
	partyChange PartyChange (0..*);
		[synonym Rosetta_Workbench value partyChange]
	otherTermsChange OtherTermsChange (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]		
}

class QuantityChange <"The primitive event to represent a change in quantity or notional.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	quantityChange ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value quantityChange]
}

class PartyChange <"The primitive event to represent a change in the parties to a contract.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	priorParties Party (2..2);
		[synonym Rosetta_Workbench value priorParties]
	newParties Party (2..2);
		[synonym Rosetta_Workbench value newParties]
}

class OtherTermsChange <"The primitive event to represent change(s) in the contractual terms.">
{
	before ContractState (0..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
}

class ObservationPrimitive <"The primitive event to represent an observation. The reason for the Primitive suffix is not to conflict with the qualified observation event.">
{
	curve Curve (1..1);
		[synonym Rosetta_Workbench value curve]
	observation number (1..1);
		[synonym Rosetta_Workbench value observation]
	date date (1..1);
		[synonym Rosetta_Workbench value date]
	time time (0..1);
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
/*
 * TO CONFIRM WITH CDM GROUP
 * Take the currency out until such time that we have an actual use case for it.
 */
//	currency CurrencyEnum (0..1);
//		[synonym Rosetta_Workbench value currency]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

class ResetPrimitive <"The primitive event to represent a reset. The reason for the Primitive suffix is not to conflict with the qualified reset event.">
{
/*
 * TO CONFIRM WITH CDM GROUP
 * The below is being replaced with the Lineage class.
 */
//	contractReference Identifier (1..1);
//		[synonym Rosetta_Workbench value contractReference]
//	observationReference Identifier (1..1);
//		[synonym Rosetta_Workbench value observationReference]
	curve Curve (1..1);
		[synonym Rosetta_Workbench value curve]
	date date (1..1);
		[synonym Rosetta_Workbench value date]
	setValue number (1..1);
		[synonym Rosetta_Workbench value setValue]
	currency CurrencyEnum (0..1);
		[synonym Rosetta_Workbench value currency]
}

//class PaymentPrimitive
//{
//	payment Payment (1..*);
//		[synonym Rosetta_Workbench value payment]
//}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1); // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
}

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1);
		[synonym Rosetta_Workbench value floatingRateIndex]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

data rule NotionalAmount_Decrease <"Logic to qualify a decrease in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount

data rule Quantity_Decrease <"Logic to qualify an increase in the notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity  -> quantity exists
	then Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity >
		Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity

data rule NotionalAmount_Remaining <"Logic to qualify a remaining notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount > 0

data rule Quantity_Remaining <"Logic to qualify a remaining quantity as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount > 0

data rule NotionalAmount_Null <"Logic to qualify a null notional amount as a result of a quantity change primitive event.">
	when Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	then Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount = 0

data rule EarlyTermination_InterestPayout_TerminationDate <"Logic to  qualify a change to an earlier termination date as a result of an other terms change primitive event.">
	when Event -> primitive -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	then Event -> primitive -> otherTermsChange ->  before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate >
		Event -> primitive -> otherTermsChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate

isEvent PartialTermination <"The qualification of a partial termination event.">
	Event -> primitive -> quantityChange exists
	and Event -> intent = IntentEnum.partialTermination
	and NotionalAmount_Decrease, NotionalAmount_Remaining apply

isEvent EarlyTermination <"The qualification of an early termination event.">
	Event -> primitive -> otherTermsChange exists
	and Event -> primitive -> otherTermsChange -> before -> contract -> contractualProduct -> economicTerms -> earlyTerminationProvision exists
	and EarlyTermination_InterestPayout_TerminationDate apply
		
isEvent Observation <"The qualification of an observation event.">
	Event -> primitive -> observation only exists 

isEvent DerivedObservation <"The qualification of a payment event.">
	(Event -> primitive -> observation 
	and Event -> functionCall) only exists

isEvent Reset <"The qualification of a reset event.">
	Event -> primitive -> reset only exists
	
isEvent Payment <"The qualification of a payment event.">
	( Event -> primitive -> payment
	and Event -> party ) only exists


