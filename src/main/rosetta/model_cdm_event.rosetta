namespace "org.isda.cdm"

class AllocationOutcome <"A class to specify the allocated outcome as the combination of an execution which state is specified as 'Allocated' and a contract or set of contract(s). (The allocation to one single contract is deemed appropriate.)">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
	contract Contract (1..*);
		[synonym Rosetta_Workbench value trade]
}

data rule AllocationOutcome_execution <"The allocation outcome must result in execution state of 'Allocated'.">
	when AllocationOutcome exists
	then AllocationOutcome -> execution -> state = StateEnum.Allocated

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before ExecutionState (1..1);
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class CashTransferBreakdown extends TransferBreakdown
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount of the payment.">;
		[synonym Rosetta_Workbench value amount]
	transferType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value type]
}

class CashTransferComponent extends TransferBase <"">
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount.">;
		[synonym Rosetta_Workbench value amount]
	transferType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value transferType]	
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">;
		[synonym Rosetta_Workbench value breakdown]
}

/*
 * TODO - The commodity transfer component and its associated breakdown should be deemed as sample implementations,
 * which need to be confirmed through relevant user stories and use cases
 */
class ComnmodityTransferBreakdown extends TransferBreakdown
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
}

class CommodityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">;
	breakdown ComnmodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction calculation (1..1);
	amount number (1..1);
	currency string (0..1) scheme;
		[synonym Rosetta_Workbench value currency meta currencyScheme]
}

class ContractState <"A class to specify a contract instantiation with respect to the before and/or after state of lifecycle events.">
{
	contract Contract (1..1);
        [synonym Rosetta_Workbench value trade]
        [synonym DTCC_11_0, DTCC_9_0 value FpML]
        [synonym DTCC_11_0, DTCC_9_0 value TradeMsg]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1) scheme; // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
		[synonym Rosetta_Workbench value commodityCurve meta commodityReferencePriceScheme]
}

class Event
{
	id (0..1);
		[synonym Rosetta_Workbench meta id]
	messageInformation MessageInformation (0..1);
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value RouteInfo path "Header.OTC_RM.Delivery"]
	timestamp EventTimestamp (1..1);
		[synonym Rosetta_Workbench value timestamp]
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Trade"]
    eventIdentifier Identifier (1..1) <"The contract identifier, which has 3 components: an actual identifier, an issuer and a version number. One and only one identifier can be associated with a lifecycle event.">;
		[synonym Rosetta_Workbench value eventIdentifier]
		[synonym DTCC_11_0, DTCC_9_0 value partyTradeIdentifier path "Header.OTC_RM.Manifest.TradeMsg.Submitter"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic. This value is derived by the CDM from the event features.">;
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym FpML_5_10 
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True]
		[synonym DTCC_11_0, DTCC_9_0 value Activity path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value Activity path "Body.OTC_Matching"]
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value party]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Trade.FpML" ]
	account Account (0..*) <"Optional account information that could be associated to the event.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value account]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">;
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event)  values and more. Those are represented through a set of rosettaKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">;
}

class EventEffect <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">
{
	effectedContract Contract (0..*) rosettaKey <"A pointer to the contract(s) to which the event effect(s) apply, i.e. in the before event state.">;
	contract Contract (0..*) rosettaKey <"A pointer to the contract effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">;
    productIdentifier ProductIdentifier (0..*) rosettaKey <"A pointer to the listed product effect(s), an example of such being the outcome of the physical exercise of a bond option.">;
	payment Payment (0..*) rosettaKey <"A pointer to the payment effect(s), an example of such being the outcome of an option cash exercise.">;
	transfer Transfer (0..*) rosettaKey <"A pointer to the transfer effect(s), either a cash, security or other asset.">;
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp <"This class corresponds to the timestamp components of the FpML MessageHeader.model. These would be applicable even if the event is communicated through a mean other than messaging (e.g. blockchain).">
{
	creationTimestamp dateTime (1..1) <"The date and time (on the source system) when this event was created.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value creationTimestamp path "header"]
		[synonym Rosetta_Workbench value creationTimestamp]
	expiryTimestamp dateTime (0..1) <"The date and time (on the source system) when this event will be considered expired.">;
		[synonym FpML_5_10 value expiryTimestamp]
}

class Execution rosettaKey
{
	identifier Identifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value identifier]
		// TODO condition mapping should handle unmapped fields
		[synonym DTCC_11_0, DTCC_9_0 value partyTradeIdentifier path "Submitter"]
	tradeDate date (1..1) id <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate meta id]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (0..*) <"The party reference is optional because positioned as part of the Event class when the execution is specified as part of such context.">;
	state StateEnum (0..1);
		[synonym Rosetta_Workbench value state]
}

class ExerciseOutcome <"The exercise outcome combines the option contract (which states would be 'Exercised' in case of a full exercise and which would have a reduced notional in case of partial exercise) and either a physical or partial exercise.">
{
	contract Contract (1..1);
		[synonym Rosetta_Workbench value contract]
	physicalExercise PhysicalExercise (0..1);
		[synonym Rosetta_Workbench value physicalExercise]
	cashExercise Cashflow (0..1);
		[synonym Rosetta_Workbench value cashExercise]
}

choice rule ExerciseOutcome_choice <"A option exercise results in either a physical or a cash exercise.">
	for ExerciseOutcome required choice between
	physicalExercise and cashExercise

class ExecutionState <"A class to specify an execution instantiation with respect to the before and/or after state of lifecycle events.">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
}

/*
 * TODO - Add data rules in relation to the fullExercise attribute
 */

class ExercisePrimitive <"This primitive leverages the FpML OptionExercise construct, except for the exerciseTiming which is deemed as associated to a request for exercise that is meant to take place, as opposed to the actual exercise event.">
{
	exerciseDate AdjustableOrAdjustedDate (0..1);
		[synonym Rosetta_Workbench value exerciseDate]
	exerciseTime BusinessCenterTime (0..1);
		[synonym Rosetta_Workbench value exerciseTime]
	fullExercise boolean (1..1);
		[synonym Rosetta_Workbench value fullExercise]
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

data rule ExercisePrimitive_fullExercise <"A full exercise should not result in ">
	when ExercisePrimitive -> fullExercise = True
	then ExercisePrimitive -> after -> contract -> state = StateEnum.Exercised

class GrossCashflow extends CashflowBase
{
	lineage Lineage (0..1) <"The lineage into the Payout components that might be associated with each of the gross cashflow elements.">;
	cashflowAmount Money (1..1) <"The currency amount of the payment.">;
		[synonym Rosetta_Workbench value cashflowAmount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType] // set cashflowType.premium when synonym premium exists]
	cashflowCalculation calculation (0..1) <"The calculation used to compute the gross cashflow, when applicable.">;
		[synonym Rosetta_Workbench value cashflowCalculation]
}

data rule EventTimestamp_ExpireTime <"The expire time should be greater than the creation time.">
	when EventTimestamp -> expiryTimestamp exists
	then EventTimestamp -> expiryTimestamp > EventTimestamp -> creationTimestamp

class Inception <"The primitive event for the inception of a new contract between parties. It is expected that this primitive will be adjusted or deprecated once the CDM scope is extended to the pre-execution space.">
{
	before ContractState (0..0) <"The (0..0) cardinality reflects the fact that there is no contract in the before state of an inception primitive. As noted in the definition associated with the class, this is expected to change once the CDM scope is extended to the pre-execution space.">;
		[synonym Rosetta_Workbench value before]
	/*
	 * Need to add the rosettaKey entry
	 */
	after ContractState (1..1) reference <"The after state corresponds to the new contract between the parties. Depending upon the implementation approach, this contract can either be explicitly stated, or referenced via either a CDM rosettaKey or a reference that originates externally from the CDM.">;
		[synonym Rosetta_Workbench value after]
		// Requires conditional mapping based on OTC_RM_11-0.TransTypeDataType
		[synonym DTCC_11_0, DTCC_9_0 value Trade path "Body.OTC_Matching"]
		[synonym DTCC_11_0, DTCC_9_0 value Manifest path "Header.OTC_RM"]
}

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1) scheme;
		[synonym Rosetta_Workbench value floatingRateIndex meta floatingRateIndexScheme]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class Lineage <"The class to provide lineage information across transactions.">
{
	contractReference string (0..*) reference; // Implementation to be adjusted to be of type Contract in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value contractReference meta href]
	eventReference string (0..*) reference; // Implementation to be adjusted to be of type Event in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value eventReference meta href]
	cashflowReference string (0..*) reference; // Implementation to be adjusted to be of type Cashflow in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value cashflowReference meta href]
	creditDefaultPayoutReference string (0..*) reference; // Implementation to be adjusted to be of type creditDefaultPayout in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value creditDefaultReference meta href]
	interestRatePayoutReference string (0..*) reference; // Implementation to be adjusted to be of type InterestRatePayout in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value interestRatePayoutReference meta href]
	optionPayoutReference string (0..*) reference; // Implementation to be adjusted to be of type optionPayout in order to accommodate a rosettaKey
		[synonym Rosetta_Workbench value optionPayoutReference meta href]
}

class MessageInformation <"This class corresponds to the messaging components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId path "messageInformation" meta messageIdScheme]
		[synonym DTCC_11_0, DTCC_9_0 value messageId path "header" meta messageIdScheme]
	sentBy string (0..1) scheme <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy path "messageInformation" meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value From]
	sentTo string (0..1) scheme <"The identifier for the recipient of a message instance.">;
		[synonym Rosetta_Workbench value sentTo path "messageInformation" meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value To]
	copyTo string (0..*) scheme  <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class PhysicalExercise <"The physical exercise results into a financial product which is represented through the Product class, with an associated quantity and cashflow (e.g. a physical exercise of a bond option will result into a bond with a cash proceed which will be a function of the option strike price).">
{
	product Product (1..1);
		[synonym Rosetta_Workbench value product]
	quantity Quantity (0..1) <"The quantity associated the asset that is physically settled. This quantity should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">;
		[synonym Rosetta_Workbench value quantity]
	cashflow Cashflow (0..1) <"The cashflow component of the physical exercise.">;
		[synonym Rosetta_Workbench value cashflow]
}

data rule PhysicalExercise_quantity <"The quantity attribute should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
	when ( PhysicalExercise -> product -> contractualProduct or PhysicalExercise -> product -> contract) exists
	then PhysicalExercise -> quantity is absent

class PrimitiveEvent <"The set of primitive events. The purpose of this class it to provide clarity with respect to the event qualification logic.">
{
	inception Inception (0..*);
		[synonym Rosetta_Workbench value inception]
	quantityChange QuantityChangePrimitive (0..*);
		[synonym Rosetta_Workbench value quantityChange]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	termsChange TermsChangePrimitive (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	payment Payment (0..*);
		[synonym Rosetta_Workbench value payment]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
	transfer Transfer (0..*);
		[synonym Rosetta_Workbench value transfer]
		[synonym DTCC_11_0, DTCC_9_0 value todo]
}

class QuantityChangePrimitive <"The primitive event to represent a change in quantity or notional.">
{
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

class ResetPrimitive <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	resetValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value resetValue]
	/*
	 * Question to the CDM Group - Should the reset primitive have an associated cashflow, or just have the rate reset value?
	 * The latter seems more appropriate, but needs to be confirmed by current operational workflows.
	 * If it has the cashflow, it should also have the associated calculation.
	 */
	cashflow Cashflow (0..1) <"The cashflow resulting from the reset event.">; // The cardinality has been relaxed until the above question is settled
		[synonym Rosetta_Workbench value cashflow]
}

class SecurityTransferBreakdown 
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..*) <"The security(ies) that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
}

class SecurityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..1) <"The security that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">;
		[synonym Rosetta_Workbench value assetTransferType]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class TermsChangePrimitive <"The primitive event to represent change(s) to the contractual terms.">
{
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location meta timezoneLocationScheme]
}

class Transfer rosettaKey <"A class to specify the transfer primitive by providing the ability to combine a set of transfer components which are specialised by asset class.">
{
	transferType TransferTypeEnum (0..1) <"The qualification of the type of transfer when associated with multiple components, e.g. a DvP settlement.">;
		[synonym Rosetta_Workbench value transferType]
	settlementDate AdjustableOrAdjustedOrRelativeDate (1..1);
		[synonym Rosetta_Workbench value settlementDate]
	cashTransfer CashTransferComponent (0..*) <"The cash transfer component of the transfer. In the case where several currencies are involved in the transfer, several components should be used, as the component supports one single currency amount.">;
		[synonym Rosetta_Workbench value cashTransfer]
	securityTransfer SecurityTransferComponent (0..*) <"The security transfer component of the transfer. In the case where several securities are involved in the transfer, several components should be used, as the component supports one single security.">;
		[synonym Rosetta_Workbench value securityTransfer]
	commodityTransfer CommodityTransferComponent (0..*);
	status TransferStatusEnum (0..1) <"The transfer status, e.g. Instructed, Settled...">;
		[synonym Rosetta_Workbench value status]
	settlementReference string (0..1) <"The settlement reference, when applicable.">;
		[synonym Rosetta_Workbench value settlementReference]
}	

class TransferBase
{
	transferCalculation calculation (0..1) <"The calculation used to compute the transfer, when applicable.">;
		[synonym Rosetta_Workbench value transferCalculation]
}

class TransferBreakdown extends TransferBase
{
	lineage Lineage (0..1) <"The lineage into the transfer components that might be associated with each of the transfer components.">;
		[synonym Rosetta_Workbench value lineage]
}

class TransferorTransferee <"A class mimicking the PayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">
{
	transferorPartyReference string (1..1) reference <"A reference to the party responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value payerPartyReference meta href]
	transferorAccountReference string (0..1) reference <"A reference to the account responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value payerAccountReference meta href]
	transfereePartyReference string (1..1) reference <"A reference to the party that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value receiverPartyReference meta href]
	transfereeAccountReference string (0..1) reference <"A reference to the account that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, DTCC_11_0, DTCC_9_0 value receiverAccountReference meta href]
}

/*********************
 * Event Qualification
 */

isEvent Allocation <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
	Event -> intent when present = IntentEnum.Allocation
	and Event -> primitive -> allocation only exists
	/*
	 * TODO - The below syntax needs to be expanded to specify a summation
	 * This could be specify as  quantityBeforeAllocation = sum(quantityAfterAllocation)
	 */
//	and quantityBeforeAllocation = quantityAfterAllocation

alias quantityBeforeAllocation <"The alias to represent the quantity or notional amount associated to a pre-allocation contractual product in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterAllocation <"The alias to represent the quantity or notional amount associated to allocated contract(s) in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

isEvent Compression <"The qualification of a compression event from the fact that (i) the intent is Compression when specified, (ii) the quantity change primitive exists, (iii) and there are multiple contracts (or contract references) specified in the before state.">
	Event -> intent when present = IntentEnum.Compression
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> quantityChange -> before -> contract multiple exists

alias contractAfterQuantityChange
	Event -> primitive -> quantityChange -> after -> contract

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of a full termination event from the fact that (i) the intent is Exercise when specified, (ii) the only primitive is the quantityChange.">
	Event -> intent when present = IntentEnum.Exercise
	and Event -> primitive -> exercise only exists

isEvent NewTrade
	Event -> intent when present = IntentEnum.NewTrade
	and Event -> primitive -> inception only exists

isEvent Novation <"The qualification of a novation event from the fact that (i) the intent is PartialNovation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract in the quantityChange/after node has a Novated state, (iv) the stepped-in contract has a different contract identifier than the novated contract, (v) the stepped-in contract has the novation event date and the novation event effective date, and (vi) the contract counterparties have changed.">
	Event -> intent when present = IntentEnum.Novation
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> state = StateEnum.Novated
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
//	and originalContractParties <> newContractParties

alias novatedContractEffectiveDate
	Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> date
	or Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate
	or Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

alias originalContractParties
	( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

alias newContractParties
	( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and 	Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists

isEvent PartialNovation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> intent when present = IntentEnum.PartialNovation
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
//	and originalContractParties <> newContractParties

data rule Novation_fee <"Logic to specify that if a payment is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> payment -> paymentType = PaymentTypeEnum.NovationFee
	then Event -> lineage -> contractReference multiple exists
		and Event -> lineage -> eventReference single exists

isEvent PartialTermination <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	Event -> intent when present = IntentEnum.PartialTermination
	and Event -> primitive -> quantityChange only exists
	or ( Event -> primitive -> quantityChange and Event -> primitive -> payment ) exists
		and Event -> primitive -> inception is absent
	/*
	 * TODO - Need to decide with the CDM Group if the event representation should provide the ability to reference a contract
	 * If this is the case, we should adjust the logic across events so that if the contract reference is used instead of the contract terms, then the intent should be specified
	 * If used as such, the below logic create an ambiguity with the partial novation.
	 */
//	or ( quantityBeforeQuantityChange > quantityAfterQuantityChange
//		and quantityAfterQuantityChange > 0.0 )

alias quantityBeforeQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">
	Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

isEvent CashTransfer <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent CashAndSecurityTransfer <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the payment.">
	Event -> primitive -> payment only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent SecurityTransfer <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent SecuritySettlement <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent Termination <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the contract state has the value 'terminated'.">
	Event -> intent when present = IntentEnum.Termination
	and Event -> primitive -> quantityChange single exists
	or quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> state = StateEnum.Terminated
