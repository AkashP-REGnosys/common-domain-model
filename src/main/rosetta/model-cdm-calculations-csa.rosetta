namespace "org.isda.cdm"
version "${project.version}"

/*
 * Variation Margin Mark to Market Calculation 
 * 
 * Goals:
 *   1. Describe a product agnostic mark-to-market calculation such that it can be used for Variation Margin valuation process;
 *   2. To be as transparent as possible in capturing which CDM elements are being used for the calculations.
 */
/*
 * Option 1 - A mark to market calculation for an FX Forward as provided by a member firm
 * 
 *   1. + requires minimal infrastructure work to support VG thread
 *   2. - delegates more work to the InterpolateForwardRate function, opaque usage of ForwardPayout
 *   3. - will not support other products
 * 
 * TODO: code generation to support comparison vs. enum values
 */
calculation FxMarkToMarket_1 <"Representation of sample mark to market calculation provided by a member firm.">
{
	= (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	  
	where
		// calculation inputs
		quotedQuantity <"The amount of the quoted currency.">: 
			if ForwardPayout -> foreignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForwardPayout -> foreignExchange -> exchangedCurrency2 -> cashflowAmount -> amount 
			else ForwardPayout -> foreignExchange -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if ForwardPayout -> foreignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForwardPayout -> foreignExchange -> exchangedCurrency1 -> cashflowAmount -> amount 
			else ForwardPayout -> foreignExchange -> exchangedCurrency2 -> cashflowAmount -> amount
			
		interpolatedRate :
			InterpolateForwardRate( ForwardPayout ) -> result
}

function InterpolateForwardRate( forward ForwardPayout )
{
	result number;
}


/*
 * Option 2 - A mark to market calculation for an FX Forward as provided by a member firm, but providing more transparency to the inputs of the interpolation function
 * 
 *   1. + explicit in which model elements are being passed into function calls
 *   2. - will require lots of product specific logic in a calculation that should be product agnostic
 * 
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 * TODO: (non-critical) Change to use alias, so to clearly distinguish between calculation inputs and 'syntactic sugar', enforce non-calc-inputs to be alias'
 * TODO: (non-critical) SpotRate( fx ) -> rate is unnecessary, SpotRate( fx ) should be enough, as it returns only 1 value 
 */
calculation FxMarkToMarket_2 <"Representation of sample mark to market calculation provided by a member firm, providing more transparency on the parameters used to interpolate the mark to market rate.">
{	
	= (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	
	where
		// variables used in the rate InterpolateFull function call, below.
		fx:
			ForwardPayout -> foreignExchange
			
		tenor:
			fx -> tenorPeriod -> periodMultiplier
			
		tenorRemaining: 
			ForwardPayout -> settlementDate - Today() -> date
			
		spotRate:
			SpotRate( fx ) -> rate
			
		forwardRate:
			ForwardRate( fx -> tenorPeriod, fx ) -> rate
		
		// actual calculation inputs
		interpolatedRate <"The interpolated rate.">: 
			Interpolate( tenor - tenorRemaining, 0, tenor, spotRate, forwardRate ) -> result
			
		quotedQuantity <"The amount of the quoted currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency2 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency1 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency2 -> cashflowAmount -> amount
}

function Today() <"Returns the current date of the operating system.">
{
	date date;
}

function Interpolate(x number,  xStart int, xEnd int, yStart number, yEnd number ) <"Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ([xStart, xEnd], [yStart, yEnd]), evaluated at x.">
{
	result number;	
}

function SpotRate( fx ForeignExchange ) <"An external market data lookup for the spot fx for the currency pair.">
{
	rate number;
}

function ForwardRate( tenor Period, fx ForeignExchange ) <"An external market data lookup for the forward fx rate for the currency pair, making use of the period specified on the Foreign Exchange contract.">
{
	rate number;
}