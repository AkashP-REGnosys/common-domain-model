Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"


 root class ContractNew
{
	economicTerms ContractualProductNew (1..1);
	collateral Collateral (0..1);
	governingLaw GoverningLawEnum (0..1);
	masterAgreement MasterAgreement (0..1);
	creditSupportAgreement CreditSupportAgreement (0..1);
	confirmation Confirmation (1..1);
}

class InterestRatePayout
{
	payerParty Party (1..1);
	receiverParty Party (1..1);
	interestRate InterestRate (1..1);
	dayCountFraction DayCountFractionEnum (1..1);
	discounting Discounting (0..1);
	compoundingMethod CompoundingMethodEnum (0..1);
	calculationPeriodDates CalculationPeriodDates (1..1);
	paymentDates PaymentDates (1..1);
	resetDates ResetDates (1..1);
}

class InterestRate one of
{
	fixedRate Schedule (0..1);
	floatingRate FloatingRateCalculation (0..1);
	inflationIndex InflationRateCalculation (0..1);
}

class ContractualQuantity one of
{
	quantity Quantity (0..1);
	notional Notional (0..1);
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
}

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
	settlementProvision SettlementProvision (0..1);
}

/*
 * New component, aimed at providing clarity with respect to the confirmation of multi-components products/strategies
 */

class Confirmation
{
	multiComponentsConfirmation boolean (1..1);
	otherConfirmationComponents TradeIdentifier (0..*);
	isConfirmed boolean (1..1);
}

data rule Confirmation_otherConfirmationComponents
	when Confirmation -> isConfirmed = True
	then Confirmation -> multiComponentsConfirmation must exist

/*
 * Product qualified approach
 */

class SwapNew
{
	interestRatePayout InterestRatePayout (1..*);
	quantity ContractualQuantity (1..1);
	crossCurrencyTerms CrossCurrencyTerms (0..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
	cancelableProvision CancelableProvision (0..1);
	extendibleProvision ExtendibleProvision (0..1);
}

class CreditDefaultSwapNew
{
	interestRatePayout InterestRatePayout (1..1);
	quantity ContractualQuantity (1..1);
	protectionTerms ProtectionTerms (1..*);
}

/*
 * Product composite approach
 * Problem with the below approach is the implied ambiguity, e.g. how would we represent a swaption?
 */

class ContractualProductNew
{
	payout Payout (1..1);
	quantity ContractualQuantity (1..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
	cancelableProvision CancelableProvision (0..1);
	extendibleProvision ExtendibleProvision (0..1);
}

class Payout
{
	interestRatePayout InterestRatePayout (0..1);
	protectionTerms ProtectionTerms (0..1);
	premium Premium (0..1);
	
}

isProduct FixFloatSwap
	ContractualProductNew -> payout -> interestRatePayout -> interestRate -> fixedRate
	and ContractualProductNew -> payout -> interestRatePayout -> interestRate -> floatingRate
	
isProduct basisSwap
	ContractualProductNew -> payout -> interestRatePayout -> interestRate -> floatingRate
	and ContractualProductNew -> payout -> interestRatePayout -> interestRate -> floatingRate
	
isProduct creditDefaultSwap
	ContractualProductNew -> payout -> interestRatePayout
	and ContractualProductNew -> payout -> protectionTerms