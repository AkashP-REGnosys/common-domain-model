Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"


/*
 * Product composite approach
 * Problem with the below approach is the implied ambiguity, e.g. how would we represent a swaption?
 * We would also need to specify a proper pre-execution view of the product
 */
 
root class ContractNew_V1
{
	economicTerms EconomicTerms (1..1);
	collateral Collateral (0..1);
	governingLaw GoverningLawEnum (0..1);
	masterAgreement MasterAgreement (0..1);
	creditSupportAgreement CreditSupportAgreement (0..1);
	confirmation Confirmation (1..1);
}

class EconomicTerms
{
	payout Payout (1..1);
	quantity ContractualQuantity (1..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
	cancelableProvision CancelableProvision (0..1);
	extendibleProvision ExtendibleProvision (0..1);
}

class Payout
{
	interestRatePayout InterestRatePayout (0..*);
	inflationIndexPayout InflationRateCalculation (0..*);
	creditDefaultPayout CreditDefaultPayout (0..1);
}

isProduct InterestRateSwap
	EconomicTerms -> payout -> interestRatePayout
	and EconomicTerms -> payout -> interestRatePayout

isProduct InflationSwap
	EconomicTerms -> payout -> interestRatePayout
	and EconomicTerms -> payout -> inflationIndexPayout
	
isProduct creditDefaultSwap
	EconomicTerms -> payout -> interestRatePayout
	and EconomicTerms -> payout -> creditDefaultPayout

/*
 * Product qualified approach
 * If we follow this approach, the ContractualProduct class is a list of the possible derivative products, as in current Rosetta model
 */

root class ContractNew_V2
{
	contractualProduct ContractualProductNew (1..1);
	collateral Collateral (0..1);
	governingLaw GoverningLawEnum (0..1);
	masterAgreement MasterAgreement (0..1);
	creditSupportAgreement CreditSupportAgreement (0..1);
	confirmation Confirmation (1..1);
}

class ContractualProductNew one of
{
	swap SwapNew (0..1);
	creditDefaultSwap CreditDefaultSwapNew (0..1);
}

class SwapNew
{
	interestRatePayout InterestRatePayout (1..*);
	quantity ContractualQuantity (1..1);
	crossCurrencyTerms CrossCurrencyTerms (0..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
	cancelableProvision CancelableProvision (0..1);
	extendibleProvision ExtendibleProvision (0..1);
}

class CreditDefaultSwapNew
{
	interestRate InterestRate (1..1);
	quantity ContractualQuantity (1..1);
	generalTerms GeneralTerms (1..1);
	protectionTerms ProtectionTerms (1..*);
	cashSettlementTerms CashSettlementTerms (0..1);
	physicalSettlementTerms PhysicalSettlementTerms (0..1);
	transactedPrice TransactedPrice (0..1) <"New class to host attributes that FpML positions as part of the feeLeg.">; 
}

choice rule CreditDefaultSwap_choice <"Choice rule to represent an FpML choice construct.">
	for CreditDefaultSwap optional choice between
	cashSettlementTerms and physicalSettlementTerms

data rule CreditDefaultSwapNew_features
	when CreditDefaultSwapNew exists
	then CreditDefaultSwapNew -> quantity -> quantity must be absent

/*
 * This approach could be used to further qualify the product or strategy, as with the current alias
 */

isProduct FixFloatSwap
	SwapNew -> interestRatePayout -> interestRate -> fixedRate
	and SwapNew -> interestRatePayout -> interestRate -> floatingRate
	
isProduct basisSwap
	SwapNew -> interestRatePayout -> interestRate -> floatingRate
	and SwapNew -> interestRatePayout -> interestRate -> floatingRate

class InterestRatePayout
{
	payerParty Party (1..1);
	receiverParty Party (1..1);
	interestRate InterestRate (0..1);
	inflationRate InflationRateCalculation (0..1);
	dayCountFraction DayCountFractionEnum (1..1);
	discounting Discounting (0..1);
	compoundingMethod CompoundingMethodEnum (0..1);
	calculationPeriodDates CalculationPeriodDates (1..1);
	paymentDates PaymentDatesNew (1..1);
	resetDates ResetDates (1..1);
}

choice rule InterestRatePayout_choice
	for InterestRatePayout required choice between
	interestRate and inflationRate

class InterestRate one of
{
	fixedRate Schedule (0..1);
	floatingRate FloatingRateCalculation (0..1);
}

class CreditDefaultPayout
{
	generalTerms GeneralTerms (1..1);
	protectionTerms ProtectionTerms (1..1);
}

class PaymentDatesNew <"Differences with the PaymentDate include addition of CDS paymentDelay element.">
{
	/*
	 * If the CDM is meant to provide a more streamlined representation, should we (i) keep the cross-referencing, or (ii) avoid/limit the need for it by stating that the
	 * calculation and reset dates are those specified as part of the payout? 
	 */
	calculationPeriodDates CalculationPeriodDates (0..1) reference;
	resetDates ResetDates (0..1) reference;
	valuationDates FxFixingDate (0..1) reference;
	paymentFrequency Frequency (1..1);
	firstPaymentDate date (0..1);
	lastRegularPaymentDate date (0..1);
	payRelativeTo PayRelativeToEnum (1..1);
	paymentDaysOffset Offset (0..1);
	paymentDatesAdjustments BusinessDayAdjustments (1..1);
	paymentDelay boolean (0..1);
}

class ContractualQuantity one of
{
	quantity QuantityNew (0..1);
	notional Notional (0..1);
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
}

class QuantityNew 
{
	quantity bigDecimal (1..1);
	unitOfMeasure UnitOfMeasureEnum (0..1);
	timeUnit TimeUnitEnum (0..1);
}

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
	settlementProvision SettlementProvision (0..1);
}

/*
 * New component, aimed at providing clarity with respect to the confirmation of multi-components products/strategies
 */

class Confirmation
{
	multiComponentsConfirmation boolean (1..1);
	otherConfirmationComponents TradeIdentifier (0..*);
	isConfirmed boolean (1..1);
}

data rule Confirmation_otherConfirmationComponents
	when Confirmation -> isConfirmed = True
	then Confirmation -> multiComponentsConfirmation must exist



class ProtectionTermsNew <"Adjusted from the FpML construct to remove the cauclationAmount, a.k.a. notional.">
{
	creditEvents CreditEvents (0..1);
	obligations Obligations (0..1);
	floatingAmountEvents FloatingAmountEvents (0..1);
}

class TransactedPrice <"These is the set of transacted price attributes currently positioned as part of the FpML FeeLeg construct.">
{
	marketFixedRate bigDecimal (0..1);
	initialPoints bigDecimal (0..1);
	marketPrice bigDecimal (0..1);
	quotationStyle QuotationStyleEnum (0..1);
}