Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"


calculation FixedAmount <"2006 ISDA Definition Article 5 section 5.1 â€¦"> {
	fixedAmount bigDecimal: amount * fixedRate * dayCountFraction  
	currency CurrencyEnum: currency
}

arguments FixedAmount {
	amount: is EconomicTerms -> quantity -> notional -> notionalStepSchedule -> initialValue
	currency: is EconomicTerms -> quantity -> notional -> notionalStepSchedule -> currency
	fixedRate: is EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate -> initialValue
    dayCountFraction: is EconomicTerms -> payout -> interestRatePayout -> dayCountFraction
}

// [[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360
calculation DayCountFractionEnum_30E_360 <"Annex 2006 ISDA Definition Article 4 section 4.16(f)"> {
	bigDecimal: (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360
}

/**
 *	Y1 - the year in which the 1st day of the Calculation/Compounding Period falls
 *	Y2 - the year in which the day immediately following the last day of the Calculation/Compounding Period falls 
 *	M1 - the month in which the 1st day of the Calculation/Compounding Period falls
 *	M2 - the month in which the day immediately following the last day of the Calculation/Compounding Period falls
 *	D1 - the 1st calendar day of the Calculation/Compounding Period (if 31, D1 will be 30)
 *	D2 - the calendar day immediately following the last day of the Calculation/Compounding Period (if 31, D2 will be 30)
 */
arguments DayCountFractionEnum_30E_360 <"">{
	alias period CalculationPeriod()
	
	endYear : is period -> endDate -> year
	startYear : is period -> startDate -> year
	endMonth : is period -> endDate -> month
	startMonth : is period -> startDate -> month
	startDay : is Min(period -> startDate -> day, 30.0)
	endDay : is Min(period -> endDate -> day + 1, 30.0)
}

calculation CalculationPeriod <"Given all periods and a date, find me the applicable period"> {
	dateRange : Within(AllCalculationPeriods(), currentPeriodDate)
}

arguments CalculationPeriod {
	currentPeriodDate: is EconomicTerms -> payout -> interestRatePayout -> paymentDates -> firstPaymentDate // -> unknown how we get this at the moment. 
}

// calculate all periods from effective date to term date
calculation AllCalculationPeriods {	
	dateRange : DateRanges(Adjust(effectiveDate), Adjust(terminationDate), paymentFrequency)
}

arguments AllCalculationPeriods {
	effectiveDate: is EconomicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate
	terminationDate: is EconomicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate
	paymentFrequency: is EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency // TODO this should be a record Type
}


/*
 * PRODUCT COMPOSITE APPROACH TO THE CDM
 * The product is dynamically inferred from the economic terms, based upon a set of definitions that are associated to the model
 * As part of it, we are looking to converge the data presentation of IRD and CDS products, while still making use of the FpML building blocks
 */
 
root class ContractNew
{
	tradeDate date (1..1);
	clearedDate date (0..1);
	derivativeProduct DerivativeProduct (1..1);
	collateral Collateral (0..1);
	governingLaw GoverningLawEnum (0..1);
	masterAgreement MasterAgreement (0..1);
	creditSupportAgreement CreditSupportAgreement (0..1);
	confirmation Confirmation (1..1); // This is a new possible attribute, to address issues currently associated with the confirmation of multi-components trades
}

class DerivativeProduct
{
	productIdentification string (1..1) isProduct <"A back-end logic to be associated to the isProduct qualifier would specify the product as a function of the associated economics.">;
	economicTerms EconomicTerms (1..1);
}

/*
 * We would need to work out the fact that a product can be specified at distinct levels...
 * One practical approach could consist in systematically returning the lowest product specification available (i.e. BasisSwap or FixFloatSwap in the below, not InterestRateSwap)
 */

isProduct InterestRateSwap
	EconomicTerms -> payout -> interestRatePayout
	and EconomicTerms -> payout -> interestRatePayout

isProduct BasisSwap
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate

isProduct FixFloatSwap
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate

isProduct InflationSwap
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate
	
isProduct creditDefaultSwap
	EconomicTerms -> payout -> interestRatePayout
	and EconomicTerms -> payout -> creditDefaultPayout

class EconomicTerms 
{
	payout Payout (1..1);
	quantity ContractualQuantity (1..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
	cancelableProvision CancelableProvision (0..1);
	extendibleProvision ExtendibleProvision (0..1);
}

class Payout
{
	interestRatePayout InterestRatePayout (0..*);
	creditDefaultPayout CreditDefaultPayout (0..1);
}

class InterestRatePayout
{
	payerParty Party (1..1);
	receiverParty Party (1..1);
	interestRate InterestRate (0..1);
	dayCountFraction DayCountFractionEnum (1..1);
	discounting Discounting (0..1);
	compoundingMethod CompoundingMethodEnum (0..1);
	calculationPeriodDates CalculationPeriodDates (1..1);
	paymentDates PaymentDatesNew (1..1);
	resetDates ResetDates (1..1);
	crossCurrencyTerms CrossCurrencyTerms (0..1); // New construct, that wraps the principleExchanges and settlementProvision terms
}

class InterestRate one of
{
	fixedRate Schedule (0..1);
	floatingRate FloatingRateCalculation (0..1);
	inflationRate InflationRateCalculation (0..1);
}

class CreditDefaultPayout
{
	generalTerms GeneralTerms (1..1);
	protectionTerms ProtectionTerms (1..1);
	cashSettlementTerms CashSettlementTerms (0..1);
	physicalSettlementTerms PhysicalSettlementTerms (0..1);
}

choice rule CreditDefaultPayout_choice <"Choice rule to represent an FpML choice construct.">
	for CreditDefaultPayout optional choice between
	cashSettlementTerms and physicalSettlementTerms

data rule CreditDefaultPayout_inflationRate <"A credit default swap should not have a fee leg ">
	when EconomicTerms -> payout -> creditDefaultPayout exists
	then EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate must be absent

class PaymentDatesNew <"Differences with the FpML PaymentDate include addition of CDS paymentDelay element.">
{
	/*
	 * If the CDM is meant to provide a more streamlined representation, should we look to limit the need for cross-referencing
	 * by stating that the calculation period dates, reset dates and fixing dates are those specified as part of the payout which those are part of?
	 */
//	calculationPeriodDates CalculationPeriodDates (0..1) reference;
//	resetDates ResetDates (0..1) reference;
//	valuationDates FxFixingDate (0..1) reference;
	paymentFrequency Frequency (1..1);
	firstPaymentDate date (0..1);
	lastRegularPaymentDate date (0..1);
	payRelativeTo PayRelativeToEnum (1..1);
	paymentDaysOffset Offset (0..1);
	paymentDatesAdjustments BusinessDayAdjustments (1..1);
	paymentDelay boolean (0..1);
}

class ContractualQuantity one of
{
	quantity QuantityNew (0..1);
	notional Notional (0..1);
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
}

class QuantityNew 
{
	quantity bigDecimal (1..1);
	unitOfMeasure UnitOfMeasureEnum (0..1);
	timeUnit TimeUnitEnum (0..1);
}

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
	settlementProvision SettlementProvision (0..1);
}

class Confirmation <"Confirmation is a new proposed model component, aimed at providing clarity with respect to the confirmation of multi-components products/strategies.">
{
	multiComponentsConfirmation boolean (1..1);
	otherConfirmationComponents TradeIdentifier (0..*);
	isConfirmed boolean (1..1);
}

data rule Confirmation_otherConfirmationComponents
	when Confirmation -> isConfirmed = True
	then Confirmation -> otherConfirmationComponents must exist

class ProtectionTermsNew <"Adjusted from the FpML construct to remove the calculationAmount, a.k.a. notional.">
{
	creditEvents CreditEvents (0..1);
	obligations Obligations (0..1);
	floatingAmountEvents FloatingAmountEvents (0..1);
}

class TransactedPrice <"These are the set of transacted price attributes currently positioned as part of the FpML FeeLeg construct.">
{
	marketFixedRate bigDecimal (0..1);
	initialPoints bigDecimal (0..1);
	marketPrice bigDecimal (0..1);
	quotationStyle QuotationStyleEnum (0..1);
}