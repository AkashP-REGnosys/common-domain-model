namespace "org.isda.cdm"

 
class Contract <"A class to specify a contract object, which can be invoked either within the context of an event, or independently from it. It corresponds to the FpML Trade, although restricted to execution and post-execution contexts. Attributes also applicable to pre-execution (a.k.a. pre-trade view in FpML) contexts have been positioned as part of the ContractualProduct class.">
{
	contractIdentifier PartyContractIdentifier (1..*) <"The contract reference identifier(s) allocated by the parties involved in the contract.">;
		[synonym FpML value partyTradeIdentifier pathExpression "trade.tradeHeader"]	
		[synonym Rosetta_Workbench value partyTradeIdentifier pathExpression "tradeHeader"]	
	tradeDate DateInstances (1..1) <"The trade date. This is the date the trade was originally executed. In the case of a novation, the novated part of the trade should be reported (by both the remaining party and the transferee) using a trade date corresponding to the date the novation was agreed. The remaining part of a trade should be reported (by both the transferor and the remaining party) using a trade date corresponding to the original execution date.">;
	clearedDate date (0..1) <"If the trade was cleared (novated) through a central counterparty clearing service, this represents the date the trade was cleared (transferred to the central counterparty).">;
		[synonym FpML value clearedDate pathExpression "trade.tradeHeader"]
		[synonym Rosetta_Workbench value clearedDate pathExpression "tradeHeader"]
	contractualProduct ContractualProduct (1..1) <"The contractual product information that is associated with the contract. The corresponding FpML construct is the product abstract element and the associated substitution group.">;
	otherPartyPayment Payment (0..*) <"Other fees or additional payments associated with the contract, e.g. broker commissions, where one or more of the parties involved are not principal parties involved in the contract.">;
		[synonym FpML value otherPartyPayment pathExpression "trade"]
		[synonym Rosetta_Workbench value otherPartyPayment]
	brokerParty string (0..*) reference <"The reference to the party (or parties) that brokered the contract.">;
		[synonym FpML value brokerPartyReference pathExpression "trade"]
		[synonym Rosetta_Workbench value brokerPartyReference]
	calculationAgent CalculationAgentModel (1..1) <"The ISDA Calculation Agent and the associated business center information. This information is represented in FpML via the CalculationAgent.model.">;
	determiningParty string (0..2) reference <"TThe party referenced is specified in the related Confirmation as Determination Party.">;
		[synonym FpML value determiningParty pathExpression "trade"]
		[synonym Rosetta_Workbench value determiningParty]
	barrierDeterminationAgent Party (0..1) reference <"The party specified in the related confirmation as Barrier Determination Agent.">;
		[synonym FpML value barrierDeterminationAgent pathExpression "trade"]
		[synonym Rosetta_Workbench value barrierDeterminationAgent]
	hedgingParty string (0..2) reference <"The ISDA Hedging Party that is specified in the related confirmation as Hedging, or if no Hedging Party is specified, either party to the contract.">;
		[synonym FpML value hedgingParty pathExpression "trade"]
		[synonym Rosetta_Workbench value hedgingParty]
	collateral Collateral (0..1) <"Defines the collateral obligations of a party.">;
		[synonym FpML value collateral pathExpression "trade"]
		[synonym Rosetta_Workbench value collateral]
	documentation Documentation (0..1) <"Defines the definitions that govern the document and should include the year and type of definitions referenced, along with any relevant documentation (such as master agreement) and the date it was signed.">;
		[synonym FpML value documentation pathExpression "trade"]
		[synonym Rosetta_Workbench value documentation]
	governingLaw GoverningLawEnum (0..1) scheme "governingLawScheme" <"Identification of the law governing the transaction.">;
		[synonym FpML value governingLaw pathExpression "trade"]
		[synonym Rosetta_Workbench value governingLaw]
	/*
	 * QUESTION TO CDM GROUP
	 * TODO - Need to confirm whether we want to associate a contractState attribute.
	 * One of the objection raised in a meeting was the fact that open/close is too simplistic as a state.
	 * Should we look to enhance the indicator with an associated qualifier, e.g. Legal, Accounting?
	 * Or should we drop this concept for the time being?
	 */
	state ContractStateEnum (0..1) <"The state qualification of a contractual product.">;
		[synonym Rosetta_Workbench value state]
	party Party (2..*) <"The parties to the contract. While FpML has a minimal cardinality of 1, a minimal cardinality of 2 seems more appropriate.">;
		[synonym FpML value party]
		[synonym Rosetta_Workbench value party]
	account Account (0..*) <"Optional account information.">;
		[synonym FpML value account]
}

data rule Contract_clearedDate
	when Contract -> clearedDate exists
	then Contract -> clearedDate >= Contract -> tradeDate -> date

data rule FpML_cd_1 <"FpML validation rule cd-1 - If referenceInformation exists, tradeDate must be before effectiveDate/unadjustedDate.">
	when Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	then Contract -> tradeDate -> date < Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

data rule FpML_cd_5 <"FpML validation rule cd-5 - If effectiveDate exists, and if scheduledTerminationDate exists, then effectiveDate/unadjustedDate must be before scheduledTerminationDate/unadjustedDate.">
	when Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate exists
	then Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate < Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> unadjustedDate

data rule FpML_cd_7 <"FpML validation rule cd-7 - If condition LongForm is true, then effectiveDate/dateAdjustments exists.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	then Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> dateAdjustments exists
	
data rule FpML_cd_8 <"FpML validation rule cd-8 - If condition LongForm is true, and if scheduledTerminationDate exists then scheduledTerminationDate/dateAdjustments exists.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	then Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> dateAdjustments exists

data rule FpML_cd_11 <"FpML validation rule cd-11 - If condition LongForm is true, and if condition ISDA2003 is true, then allGuarantees must exist.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		and Contract -> documentation -> contractualDefinitions = ContractualDefinitionsEnum.ISDA2003Credit
	then Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees = True

data rule FpML_cd_19 <"FpML validation rule cd-19 - If the condition ISDA1999Credit is true, then the following elements must not exist: protectionTerms/creditEvents/creditEventNotice/businessCenter, protectionTerms/creditEvents/restructuring/multipleHolderObligation, protectionTerms/creditEvents/restructuring/multipleCreditEventNotices, generalTerms/referenceInformation/allGuarantees, generalTerms/indexReferenceInformation, generalTerms/substitution, generalTerms/modifiedEquityDelivery.">
	when Contract -> documentation -> contractualDefinitions = ContractualDefinitionsEnum.ISDA1999Credit
	then (Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> businessCenter
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleHolderObligation 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> restructuring -> multipleCreditEventNotices
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> allGuarantees
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> substitution
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> modifiedEquityDelivery)
		is absent

data rule FpML_cd_20 <"FpML validation rule cd-20 - If the condition ISDA2003 is true, then protectionTerms/obligations/notContingent must not exist."> 
	when Contract -> documentation -> contractualDefinitions = ContractualDefinitionsEnum.ISDA2003Credit
	then Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations -> notContingent is absent

data rule FpML_cd_23 <"FpML validation rule cd-23 - If the condition LongForm is true, then cashSettlementTerms or physicalSettlementTerms must exist.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	then ( Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> cashSettlementTerms or Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms ) exists

data rule FpML_cd_24 <"FpML validation rule cd-24 - If the condition LongForm is true, then the following elements must exist: protectionTerms/creditEvents/creditEventNotice, protectionTerms/obligations, generalTerms/referenceInformation/referencePrice.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	then ( Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> obligations 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout ->generalTerms -> referenceInformation -> referencePrice ) exists

data rule FpML_cd_25 <"FpML validation rule cd-25 - If the condition LongForm is true, and if physicalSettlementTerms exists, then physicalSettlementTerms must contain settlementCurrency, physicalSettlementPeriod, escrow and deliverableObligations/accruedInterest.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms exists
	then ( Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> settlementCurrency 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> physicalSettlementPeriod
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> escrow 
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> physicalSettlementTerms -> deliverableObligations -> accruedInterest ) exists

data rule FpML_cd_32 <"FpML validation rule cd-32 - If condition LongForm is true, and if fixedAmountCalculation/calculationAmount exists, then fixedAmountCalculation/dayCountFraction must exist.">
	when ( Contract -> documentation -> masterConfirmation or Contract -> documentation -> contractualMatrix ) is absent
		and Contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation exists
	 	and Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount exists
	 	then Contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> dayCountFraction exists

class ContractualProduct <"The contractual product class is meant to be used across the entire pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
{
	productIdentification string (1..1) isProduct;
	productTaxonomy ProductTaxonomy (1..*) <"The product taxonomy value(s) associated with a contractual product.">;
	economicTerms EconomicTerms (1..1);
}

class ContractualQuantity
{
	notionalReference string (0..1) reference <"The notional amount when specified by reference to the notional specified somewhere else in the instance document.">;
		[synonym FpML value notionalReference pathExpression "trade.creditDefaultSwapOption"]
	quantity Quantity (0..1);
	notionalAmount Money (0..1) <"When applied to Credit default Swaps, this is the notional amount of protection coverage. ISDA 2003 Term: Floating Rate Payer Calculation Amount">;
		[synonym FpML value initialValue pathExpression "calculationPeriodAmount.calculation" set notionalAmount when notionalSchedule -> notionalStepSchedule -> step is absent]
		[synonym FpML value calculationAmount pathExpression "periodicPayment.fixedAmountCalculation"]
		[synonym FpML value calculationAmount pathExpression "periodicPayment.floatingAmountCalculation"]
		[synonym FpML value notionalAmount pathExpression "trade.bondOption"]
		[synonym Rosetta_Workbench value notionalAmount]
	notionalSchedule NotionalSchedule (0..1);
		[synonym FpML value notionalSchedule pathExpression "calculationPeriodAmount.calculation" set notionalSchedule when notionalSchedule -> notionalStepSchedule -> step exists]
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
		[synonym FpML value fxLinkedNotionalSchedule pathExpression "calculationPeriodAmount.calculation" set notionalSchedule when fxLinkedNotional -> initialValue exists ]
	futureValueNotional FutureValueAmount (0..1);
	 	[synonym FpML value futureValueNotional pathExpression "calculationPeriodAmount.calculation"]
}

choice rule ContractualQuantity_choice <"The below set of notional values are exclusive, while some of those could be associated with the futureValueNotional.">
	for ContractualQuantity optional choice between
	quantity and notionalAmount and notionalSchedule and fxLinkedNotional

data rule InterestRatePayout_futureValueNotional <"The BRL CDI future value notional only applies to a fixed Rate Schedule.">
	when InterestRatePayout -> interestRate -> fixedRate is absent
	then InterestRatePayout -> quantity -> futureValueNotional is absent

data rule FutureValueNotional_terminationDate <"FpML states that the value date associated with the future value notional should match the adjusted termination date.">
	when InterestRatePayout -> quantity -> futureValueNotional exists
	then InterestRatePayout -> quantity -> futureValueNotional -> valueDate = InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustedDate

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
		[synonym FpML value principalExchanges]
	settlementProvision SettlementProvision (0..1);
		[synonym FpML value settlementProvision]
}

/*
 * TODO - Need to cross-reference the 2014 credit definitions when relevant. 
 * (FpML schema has not been updated to reflect those definitions.)
 */
class CreditDefaultPayout <"The credit default payout specification terms.">
{
	generalTerms GeneralTerms (1..1) <"This element contains all the data that appears in the section entitled '1. General Terms' in the 2003 ISDA Credit Derivatives Confirmation, except for the effectiveDate, terminationDate and dateAdjustments elements, which have been positioned as part of the InterestRatePayout class.">;
	protectionTerms ProtectionTerms (1..1) <"The credit protection terms.">;
		[synonym FpML value protectionTerms pathExpression "trade.creditDefaultSwap"]
		[synonym FpML value protectionTerms pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap"]
		[synonym Rosetta_Workbench value protectionTerms pathExpression "creditDefaultSwap"]
	cashSettlementTerms CashSettlementTerms (0..1);
		[synonym FpML value cashSettlementTerms pathExpression "trade.creditDefaultSwap"]
		[synonym FpML value cashSettlementTerms pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap"]
	physicalSettlementTerms PhysicalSettlementTerms (0..1);
		[synonym FpML value physicalSettlementTerms pathExpression "trade.creditDefaultSwap"]
		[synonym FpML value physicalSettlementTerms pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap"]
	transactedPrice TransactedPrice (0..1) <"The qualification of the price at which the contract has been transacted, in terms of market fixed rate, initial points, market price and/or quotation style. In FpML, those attributes are positioned as part of the fee leg.">;
}

data rule FpML_cd_12 <"FpML validation rule cd-12 - If referencePrice exists, referencePrice must be greater or equal to 0">
	when CreditDefaultPayout -> generalTerms -> referenceInformation -> referencePrice exists
	then CreditDefaultPayout -> generalTerms -> referenceInformation -> referencePrice >= 0

data rule FpML_cd_13 <"FpML validation rule cd-13 - If protectionTerms/creditEvents/creditEventNotice/notifyingParty/buyerPartyReference exists, then the @href attribute of protectionTerms/creditEvents/creditEventNotice/notifyingParty/buyerPartyReference is equal to the @href attribute of generalTerms/buyerPartyReference.">
	when CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> buyerPartyReference exists
	then CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> buyerPartyReference = CreditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
	
data rule FpML_cd_14 <"FpML validation rule cd-14 - If protectionTerms/creditEvents/creditEventNotice/notifyingParty/sellerPartyReference exists, then the @href attribute of protectionTerms/creditEvents/creditEventNotice/notifyingParty/sellerPartyReference must be equal to the @href attribute of generalTerms/sellerPartyReference.">
	when CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> sellerPartyReference exists
	then CreditDefaultPayout -> protectionTerms -> creditEvents -> creditEventNotice -> notifyingParty -> sellerPartyReference = CreditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference

choice rule CreditDefaultPayout_choice <"Choice rule to represent an FpML choice construct.">
	for CreditDefaultPayout optional choice between
	cashSettlementTerms and physicalSettlementTerms

class EconomicTerms <"This class represents the full set of product economics: the payout component, as well as the legal optional provisions which have valuation implications.">
{
	payout Payout (1..1) <"The payout specification, which can combine several payout terms, e.g. an interest rate and a credit default payout in the case of a credit default swap.">;
	earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">;
		[synonym FpML value earlyTerminationProvision pathExpression "trade.swap"]
	cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">;
		[synonym FpML value cancelableProvision pathExpression "trade.swap"]
	extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">;
}

class GeneralTerms <"A class specifying the general terms of the credit default payout. It corresponds to the FpML GeneralTerms complex type, minus the effectiveDate, terminationDate and dateAdjustments elements, which have been positioned as part of the InterestRatePayout class.">
{
	buyerSeller BuyerSeller (1..1);
	dateAdjustments BusinessDayAdjustments (0..1) <"ISDA 2003 Terms: Business Day and Business Day Convention.">;
		[synonym FpML value dateAdjustments pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value dateAdjustments pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value dateAdjustments pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value dateAdjustments pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
	referenceInformation ReferenceInformation (0..1);
		[synonym FpML value referenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value referenceInformation pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value referenceInformation pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value referenceInformation pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
	indexReferenceInformation IndexReferenceInformation (0..1);
		[synonym FpML value indexReferenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value indexReferenceInformation pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value indexReferenceInformation pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value indexReferenceInformation pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
	basketReferenceInformation BasketReferenceInformation (0..1);
		[synonym FpML value basketReferenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value basketReferenceInformation pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value basketReferenceInformation pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value basketReferenceInformation pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
	additionalTerm string (0..*) scheme "additionalTermScheme";
		[synonym FpML value additionalTerm pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value additionalTerm pathExpression "creditDefaultSwap.generalTerms"]
	substitution boolean (1..1); // As a departure from FpML, the proposal is to remove optional cardinality in a boolean attribute. See class PaymentDates for proposed resolution.
		[synonym FpML value substitution pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value substitution pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value substitution pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value substitution pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
	modifiedEquityDelivery boolean (1..1); // As a departure from FpML, the proposal is to remove optional cardinality in a boolean attribute. See class PaymentDates for proposed resolution.
		[synonym FpML value modifiedEquityDelivery pathExpression "trade.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value modifiedEquityDelivery pathExpression "creditDefaultSwap.generalTerms"]
		[synonym FpML value modifiedEquityDelivery pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
		[synonym Rosetta_Workbench value modifiedEquityDelivery pathExpression "creditDefaultSwapOption.creditDefaultSwap.generalTerms"]
}

choice rule GeneralTerms_choice <"Choice rule to represent an FpML choice construct.">
	for GeneralTerms required choice between
	referenceInformation and indexReferenceInformation and basketReferenceInformation

data rule FpML_cd_41 <"FpML validation rule cd-41 - If indexReferenceInformation/tranche does not exist, then modifiedEquityDelivery must not exist.">
	when GeneralTerms -> indexReferenceInformation -> tranche is absent
	then GeneralTerms -> modifiedEquityDelivery is absent
	
data rule FpML_cd_42 <"FpML validation rule cd-42 - If basketReferenceInformation does not exist, then substitution must not exist.">
	when GeneralTerms -> basketReferenceInformation is absent
	then GeneralTerms -> substitution is absent

class InterestRate one of
{
	fixedRate Schedule (0..1) <"The fixed rate or fixed rate schedule expressed as explicit fixed rates and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">;
	floatingRate FloatingRateCalculation (0..1) <"A floating rate calculation definition.">;
	inflationRate InflationRateCalculation (0..1) <"An inflation rate calculation definition.">;
		[synonym FpML value inflationRateCalculation pathExpression "calculationPeriodAmount.calculation"]
}

class InterestRatePayout extends PayerReceiver calculation FixedAmount, FloatingAmount <"The interest rate payout specification terms.">
{
	id string (0..1) anchor;
		[synonym FpML value id]
	quantity ContractualQuantity (1..1) <"The quantity can be expressed in different formats, depending upon the product, e.g. notional amount for credit and interest rate products, quantity for some of the equity products. The CDM uses the generic term quantity rather than notional amount.">;
	interestRate InterestRate (0..1) <"The interest rate can be a floating rate, a fixed rate of an inflation rate.">;
	dayCountFraction DayCountFractionEnum (1..1) scheme "dayCountFractionScheme" <"The day count fraction.">;
		[synonym FpML value dayCountFraction pathExpression "calculationPeriodAmount.calculation"]
		[synonym FpML value dayCountFraction pathExpression "periodicPayment.fixedAmountCalculation"]
		[synonym FpML value dayCountFraction pathExpression "periodicPayment.floatingAmountCalculation"]
	discounting Discounting (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">;
		[synonym FpML value discounting pathExpression "calculationPeriodAmount.calculation"]
	compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">;
		[synonym FpML value compoundingMethod pathExpression "calculationPeriodAmount.calculation"]
	calculationPeriodDates CalculationPeriodDates (1..1) <"The calculation period dates schedule.">;
	paymentDates PaymentDates (1..1) <"The payment dates schedule.">;
	resetDates ResetDates (1..1) <"The reset dates schedule. The reset dates schedule only applies for a floating rate stream.">;
		[synonym FpML value resetDates]
	cashflows Cashflows (0..1) <"The cashflow representation of the swap stream.">;
		[synonym FpML value cashflows]
	crossCurrencyTerms CrossCurrencyTerms (0..1) <"The specification of the principle exchange and settlement provision terms.">;
	stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">;
		[synonym FpML value stubCalculationPeriodAmount]
/*
 * QUESTION TO CDM GROUP
 * TODO - Cannot locate an asset swap example in the FpML samples to test this provision
 * It would be good to get a sample trade from a member
 */
	bondReference BondReference (0..1) <"Reference to a bond underlyer to represent an asset swap or Condition Precedent Bond.">;
		[synonym FpML value bondReference]
}

data rule FpML_ird_1 <"FpML validation rule ird-1 - Reset dates must exist if and only if a floating rate or inflation rate exists.">
	when InterestRatePayout -> resetDates exists
	then (InterestRatePayout -> interestRate -> floatingRate 
		or InterestRatePayout -> interestRate-> inflationRate) exists

data rule FpML_ird_6 <"FpML validation rule ird-6 - If paymentDates/firstPaymentDate exists, and if calculationPeriodDates/effectiveDate exists, then paymentDates/firstPaymentDate must be after calculationPeriodDates/effectiveDate/unadjustedDate.">
	when InterestRatePayout -> paymentDates -> firstPaymentDate exists 
		and InterestRatePayout -> calculationPeriodDates -> effectiveDate exists
	then InterestRatePayout -> paymentDates -> firstPaymentDate > InterestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

data rule FpML_ird_8 <"FpML validation rule ird-8 - The @href attribute of payerPartyReference must not be equal to the @href attribute of receiverPartyReference. If they are equal, and if payerAccountReference and receiverAccountReference both exist, the @href attribute of payerAccountReference must not be equal to the @href attribute of receiverAccountReference">
	when InterestRatePayout exists
	then InterestRatePayout -> payerPartyReference <> InterestRatePayout -> receiverPartyReference
		or InterestRatePayout -> payerAccountReference <> InterestRatePayout -> receiverAccountReference

data rule InitialStub_firstPaymentDate <"FpML specifies that firstPaymentDate must only be included if there is an initial stub.">
	when InterestRatePayout -> stubPeriod -> initialStub is absent
	then InterestRatePayout -> paymentDates -> firstPaymentDate is absent 

data rule FinalStub_lastRegularPaymentDate <"FpML specifies that lastRegularPaymentDate must only be included if there is an final stub.">
	when InterestRatePayout -> stubPeriod -> finalStub is absent
	then InterestRatePayout -> paymentDates -> lastRegularPaymentDate is absent

data rule InterestRatePayout_quantity <"The quantity associated to an interest rate payout should not be expressed as a quantity, but rather as a notional (which can itself be expressed in a number of distinct ways).">
	when InterestRatePayout exists
	then InterestRatePayout -> quantity -> quantity is absent

/*
 * TODO - Need for an associated logic that will parse the respective legs of the swap, as this is not made explicit at present as part of the syntax
 */	
data rule FpML_ird_7_1 <"FpML validation rule ird-7 1/2 - The existence of compoundingMethod is prohibited when the calculation-period and payment frequencies are the same.">
 	when InterestRatePayout -> paymentDates -> paymentFrequency -> period = InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		and InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier
 	then InterestRatePayout -> compoundingMethod is absent
 	
data rule FpML_ird_7_2 <"FpML validation rule ird-7 2/2 - The existence of compoundingMethod is required when the calculation-period and payment frequencies differ.">
 	when (InterestRatePayout -> paymentDates -> paymentFrequency -> period <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		and InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
 	or (InterestRatePayout -> paymentDates -> paymentFrequency -> period <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		or InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
 	then InterestRatePayout -> compoundingMethod exists

data rule FpML_ird_9 <"FpML validation rule ird-9 - If calculationPeriodAmount/calculation/compoundingMethod exists, then resetDates must exist.">
	when InterestRatePayout -> compoundingMethod exists
	then InterestRatePayout -> resetDates exists

data rule FpML_ird_29 <"FpML validation rule ird-29 - If compoundingMethod exists, then fixedRateSchedule must not exist.">
	when InterestRatePayout -> compoundingMethod exists
	then InterestRatePayout -> interestRate -> fixedRate is absent

data rule CalculationPeriodDates_firstCompoundingPeriodEndDate <"FpML specifies that the firstCompoundingPeriodEndDate must only be specified when the compounding method is specified and not equal to a value of None.">
	when InterestRatePayout -> compoundingMethod is absent
		or InterestRatePayout -> compoundingMethod = CompoundingMethodEnum.None
	then InterestRatePayout -> calculationPeriodDates -> firstCompoundingPeriodEndDate is absent

class NotionalSchedule <"A class specifying defining the notional amount or notional amount schedule associated with a contractual product. The notional schedule will be captured explicitly, specifying the dates that the notional changes and the outstanding notional amount that applies from that date. A parametric representation of the rules defining the notional step schedule can optionally be included.">
	[synonym FpML value Notional]
{
	id string (0..1);
		[synonym FpML value id]
	notionalStepSchedule NonNegativeAmountSchedule (1..1) <"The notional amount or notional amount schedule expressed as explicit outstanding notional amounts and dates. In the case of a schedule, the step dates may be subject to adjustments in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">;
		[synonym FpML value notionalStepSchedule]
	notionalStepParameters NotionalStepRule (0..1) <"A parametric representation of the notional step schedule, i.e. parameters used to generate the notional schedule.">;
		[synonym FpML value notionalStepParameters]
}

data rule FpML_ird_61 <"FpML validation rule ird-61 - Context: NonNegativeSchedule (complex type). If step does not exist, then initialValue must not be equal to 0.">
	when NotionalSchedule -> notionalStepSchedule -> step is absent
	then NotionalSchedule -> notionalStepSchedule -> initialValue <>0.0

class OptionExercise <"A class to represent the applicable terms to qualify an option exercise: the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">
{
	optionStyle OptionStyle (1..1) <"The option exercise can be of American style, Bermuda style or European style. The FpML implementation makes use of a substitution group.">;
	strike OptionStrike (0..1) <"Specifies the strike of the option on credit default swap.">;
		[synonym FpML value strike pathExpression "trade.creditDefaultSwapOption"]
		[synonym Rosetta_Workbench value strike pathExpression "creditDefaultSwapOption"]
		[synonym FpML value strike pathExpression "trade.bondOption"]
		[synonym Rosetta_Workbench value strike pathExpression "bondOption"]
	exerciseProcedure ExerciseProcedure (1..1) <"The set of parameters defining the procedure associated with the exercise, e.g. manual exercise.">;
		[synonym FpML value exerciseProcedure pathExpression "trade.swaption"]
		[synonym Rosetta_Workbench value exerciseProcedure pathExpression "swaption"]
		[synonym FpML value exerciseProcedure pathExpression "trade.creditDefaultSwapOption"]
		[synonym Rosetta_Workbench value exerciseProcedure pathExpression "creditDefaultSwapOption"]
		[synonym FpML value exerciseProcedure pathExpression "trade.bondOption"]
		[synonym Rosetta_Workbench value exerciseProcedure pathExpression "bondOption"]
	settlement OptionSettlement (0..1) <"The option settlement terms, such as cash vs. physical, the settlement date, the settlement currency and/or amount. FpML represents this information as part of the OptionSettlement.model.">;
}

class OptionPayout <"The option payout specification terms.">
{
	buyerSeller BuyerSeller (1..1);
	optionType OptionTypeEnum (1..1) <"The type of option transaction. From a usage standpoint, put/call is the default option type, while payer/receiver indicator is used for options on index credit default swaps, consistently with the industry practice. Straddle is used for the case of straddle strategy, that combine a call and a put with the same strike.">;
		[synonym FpML value optionType pathExpression "trade.creditDefaultSwapOption"]
		[synonym Rosetta_Workbench value optionType pathExpression "creditDefaultSwapOption"]
		[synonym FpML value optionType pathExpression "trade.bondOption"]
		[synonym Rosetta_Workbench value optionType pathExpression "bondOption"]
/*
 * TODO - Need to implement a mapping logic to map the FpML swaption straddle boolean flag into the common optionType
 */
//		[synonym FpML value optionType set optionType.straddle when synonym trade.swaption.swaptionStraddle = True ]
	feature OptionFeature (0..1) <"The option feature, such as quanto, Asian, barrier, knock.">;
		[synonym FpML value feature pathExpression "trade.creditDefaultSwapOption"]
	denomination OptionDenomination (0..1) <"The denomination qualifies the number of units of underlyer per option and the number of options comprised in the option transaction. FpML represents this information as part of the OptionDenomination.model.">;
	quantity ContractualQuantity (0..1) <"The option notional amount. The CDM uses the generic term quantity rather than notional amount. The number of options is specified as part of the denomination attribute.">;
	exerciseTerms OptionExercise (1..1) <"The terms for exercising the option, which include the option style (e.g. American style option), the exercise procedure (e.g. manual exercise) and the settlement terms (e.g. physical vs. cash).">;
	underlyer Product (1..1) <"The option underlyer. The implementation is restricted to contractual underlyers as part of the initial CDM phase.">;
}

class PaymentDates <"The payment dates schedule. As a difference from the FpML PaymentDate, this class incorporates the CDS paymentDelay element, and the following reference elements have been omitted, because deemed of no relevant usage by the ISDA CDM Group: calculationPeriodDatesReference, resetDatesReference, ValuationDatesReference.">
{
	id string (0..1) anchor;
		[synonym FpML value id pathExpression "paymentDates"]
	calculationPeriodDatesReference string (0..1) reference <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">;
		[synonym FpML value calculationPeriodDatesReference pathExpression "paymentDates"]
	resetDatesReference string (0..1) reference <"A pointer style reference to the associated reset dates component defined elsewhere in the document.">;
		[synonym FpML value resetDatesReference pathExpression "paymentDates"]
	valuationDatesReference string (0..1) reference <"A pointer style reference to the associated valuation dates component defined elsewhere in the document. Implemented for Brazilian-CDI Swaps where it will refer to the settlemementProvision/nonDeliverableSettlement/fxFixingDate structure.">;
		[synonym FpML value valuationDatesReference pathExpression "paymentDates"]
	paymentFrequency Frequency (1..1) <"The frequency at which regular payment dates occur. If the payment frequency is equal to the frequency defined in the calculation period dates component then one calculation period contributes to each payment amount. If the payment frequency is less frequent than the frequency defined in the calculation period dates component then more than one calculation period will contribute to the payment amount. A payment frequency more frequent than the calculation period frequency or one that is not a multiple of the calculation period frequency is invalid. If the payment frequency is of value T (term), the period is defined by the effectiveDate and the terminationDate.">;
		[synonym FpML value paymentFrequency pathExpression "paymentDates"]
		[synonym FpML value paymentFrequency pathExpression "periodicPayment"]
	firstPaymentDate date (0..1) <"The first unadjusted payment date. This day may be subject to adjustment in accordance with any business day convention specified in paymentDatesAdjustments. This element must only be included if there is an initial stub. This date will normally correspond to an unadjusted calculation period start or end date. This is true even if early or delayed payment is specified to be applicable since the actual first payment date will be the specified number of days before or after the applicable adjusted calculation period start or end date with the resulting payment date then being adjusted in accordance with any business day convention specified in paymentDatesAdjustments.">;
		[synonym FpML value firstPaymentDate pathExpression "paymentDates"]
		[synonym FpML value firstPaymentDate pathExpression "periodicPayment"]
	lastRegularPaymentDate date (0..1) <"The last regular unadjusted payment date. This day may be subject to adjustment in accordance with any business day convention specified in paymentDatesAdjustments. This element must only be included if there is a final stub. All calculation periods after this date contribute to the final payment. The final payment is made relative to the final set of calculation periods or the final reset date as the case may be. This date will normally correspond to an unadjusted calculation period start or end date. This is true even if early or delayed payment is specified to be applicable since the actual last regular payment date will be the specified number of days before or after the applicable adjusted calculation period start or end date with the resulting payment date then being adjusted in accordance with any business day convention specified in paymentDatesAdjustments.">;
		[synonym FpML value lastRegularPaymentDate pathExpression "paymentDates"]
		[synonym FpML value lastRegularPaymentDate pathExpression "periodicPayment"]
	payRelativeTo PayRelativeToEnum (1..1) <"Specifies whether the payments occur relative to each adjusted calculation period start date, adjusted calculation period end date or each reset date. The reset date is applicable in the case of certain euro (former French Franc) floating rate indices. Calculation period start date means relative to the start of the first calculation period contributing to a given payment. Similarly, calculation period end date means the end of the last calculation period contributing to a given payment. The valuation date is applicable for Brazilian-CDI swaps.">;
		[synonym FpML value payRelativeTo pathExpression "paymentDates"]
	paymentDaysOffset Offset (0..1) <"If early payment or delayed payment is required, specifies the number of days offset that the payment occurs relative to what would otherwise be the unadjusted payment date. The offset can be specified in terms of either calendar or business days. Even in the case of a calendar days offset, the resulting payment date, adjusted for the specified calendar days offset, will still be adjusted in accordance with the specified payment dates adjustments. This element should only be included if early or delayed payment is applicable, i.e. if the periodMultiplier element value is not equal to zero. An early payment would be indicated by a negative periodMultiplier element value and a delayed payment (or payment lag) would be indicated by a positive periodMultiplier element value.">;
		[synonym FpML value paymentDaysOffset pathExpression "paymentDates"]
	paymentDatesAdjustments BusinessDayAdjustments (1..1) <"The business day convention to apply to each payment date if it would otherwise fall on a day that is not a business day in the specified financial business centers.">;
		[synonym FpML value paymentDatesAdjustments pathExpression "paymentDates"]
	paymentDelay boolean (1..1) <"Applicable to CDS on MBS to specify whether payment delays are applicable to the fixed Amount. RMBS typically have a payment delay of 5 days between the coupon date of the reference obligation and the payment date of the synthetic swap. CMBS do not, on the other hand, with both payment dates being on the 25th of each month.">; 
/*
 * TODO - In order not to introduce optional boolean attributes, the below mapping syntax needs to be supported
 */
		[synonym FpML value paymentDelay]
//		[synonym FpML value paymentDelay set paymentDelay to False when absent]
}

choice rule PaymentDates_references <"Choice rule to represent an FpML choice construct.">
	for PaymentDates required choice between
	calculationPeriodDatesReference and resetDatesReference and valuationDatesReference

data rule PaymentDates_firstPaymentDate_lastRegularPaymentDate <"FpML validation rule ird-35 - If firstPaymentDate exists, and if lastRegularPaymentDate exists, then firstPaymentDate must be before lastRegularPaymentDate.">
	when PaymentDates -> firstPaymentDate exists 
		and PaymentDates -> lastRegularPaymentDate exists
	then PaymentDates -> firstPaymentDate < PaymentDates -> lastRegularPaymentDate
	
data rule PaymentDates_paymentDaysOffset <"FpML specifies that paymentDaysOffset should only be included if early or delayed payment is applicable, i.e. if the periodMultiplier element value is not equal to zero.">
	when PaymentDates -> paymentDaysOffset exists
	then PaymentDates -> paymentDaysOffset -> periodMultiplier <> 0

class Payout <"The payout can be specified through a number of combinations, e.g. by associating several interest rate payouts to specify an interest rate swap, or a credit default and an interest rate payout to specify a credit default swap. The implied product is inferred by the isProduct CDM artefact.">
{
	interestRatePayout InterestRatePayout (0..*);
		[synonym FpML value swapStream pathExpression "trade.swap"]
		[synonym Rosetta_Workbench value swapStream pathExpression "swap"]
		[synonym FpML value swapStream pathExpression "trade.swaption.swap"]
		[synonym Rosetta_Workbench value swapStream pathExpression "swaption.swap"]
		[synonym FpML value feeLeg pathExpression "trade.creditDefaultSwap"]
		[synonym Rosetta_Workbench value feeLeg pathExpression "creditDefaultSwap"]
		[synonym FpML value feeLeg pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap"]
		[synonym Rosetta_Workbench value feeLeg pathExpression "creditDefaultSwapOption.creditDefaultSwap"]
		[synonym FpML value generalTerms pathExpression "trade.creditDefaultSwap"]
		[synonym Rosetta_Workbench value generalTerms pathExpression "creditDefaultSwap"]
		[synonym FpML value generalTerms pathExpression "trade.creditDefaultSwapOption.creditDefaultSwap"]
		[synonym Rosetta_Workbench value generalTerms pathExpression "creditDefaultSwapOption.creditDefaultSwap"]
	creditDefaultPayout CreditDefaultPayout (0..1);
	cashflow Payment (0..*) <"A payment between the parties to the trade. For interest rate products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the initialPayment element and the singlePayment element of the fee leg.">;
		[synonym FpML value additionalPayment pathExpression "trade.swap"]
		[synonym Rosetta_Workbench value additionalPayment pathExpression "swap"]
		[synonym FpML value initialPayment pathExpression "trade.creditDefaultSwap.feeLeg"]
		[synonym Rosetta_Workbench value initialPayment pathExpression "creditDefaultSwap.feeLeg"]
		[synonym FpML value singlePayment pathExpression "trade.creditDefaultSwap.feeLeg"]
		[synonym Rosetta_Workbench value singlePayment pathExpression "creditDefaultSwap.feeLeg"]
		[synonym FpML value premium pathExpression "trade.swaption"]
		[synonym Rosetta_Workbench value premium pathExpression "swaption"]
		[synonym FpML value premium pathExpression "trade.creditDefaultSwapOption"]
		[synonym Rosetta_Workbench value premium pathExpression "creditDefaultSwapOption"]
		[synonym FpML value premium pathExpression "trade.bondOption"]
		[synonym Rosetta_Workbench value premium pathExpression "bondOption"]
	optionPayout OptionPayout (0..*);
}

data rule FpML_cd_26_28 <"This data rule corresponds to two FpML validation rules, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute. FpML validation rule cd-26 - If feeLeg/singlePayment/adjustablePaymentDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be after generalTerms/effectiveDate/unadjustedDate. FpML validation rule cd-28 - If feeLeg/periodicPayment/firstPaymentDate exists, then feeLeg/periodicPayment/firstPaymentDate must be after generalTerms/effectiveDate/unadjustedDate.">
	when Payout -> creditDefaultPayout exists
	and Payout -> cashflow exists
	then Payout -> cashflow -> paymentDate -> adjustableDate -> unadjustedDate > Payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

data rule FpML_cd_27_29 <"This data rule corresponds to two FpML validation rules, as the singlePayment and the firstPayment have been represented through the same Payout/cashflow attribute. FpML validation rule cd-27 - If feeLeg/singlePayment/adjustablePaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/singlePayment/adjustablePaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate. FpML validation rule cd-29 - If feeLeg/periodicPayment/firstPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/firstPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
	when Payout -> creditDefaultPayout exists
	and Payout -> cashflow exists
	then Payout -> cashflow -> paymentDate -> adjustableDate -> unadjustedDate < Payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> unadjustedDate

data rule FpML_cd_30 <"FpML validation rule cd-30 - If feeLeg/periodicPayment/lastRegularPaymentDate exists, and if generalTerms/scheduledTerminationDate exists, then feeLeg/periodicPayment/lastRegularPaymentDate must be before generalTerms/scheduledTerminationDate/unadjustedDate.">
	when (Payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate 
		and Payout -> interestRatePayout -> calculationPeriodDates -> terminationDate) exists
	then Payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate < Payout -> interestRatePayout -> calculationPeriodDates -> terminationDate -> unadjustedDate
	
data rule FpML_cd_31 <"FpML validation rule cd-31 - If firstPaymentDate exists, and if lastRegularPaymentDate exists, then firstPaymentDate must be before lastRegularPaymentDate.">
	when (Payout -> interestRatePayout -> paymentDates -> firstPaymentDate
		and Payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate) exists
	then Payout -> interestRatePayout -> paymentDates -> firstPaymentDate < Payout -> interestRatePayout -> paymentDates -> lastRegularPaymentDate

class Product one of
{
	contractualProduct ContractualProduct (0..1);
	listedProduct ListedProduct (0..1);
}

class Quantity
{
	amount number (1..1);
	unitOfMeasure UnitOfMeasureEnum (0..1);
	timeUnit TimeUnitEnum (0..1);
}

class StubPeriod <"A class defining how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or final stub calculation period may be the linear interpolation of two different tenors for the floating rate index specified in the calculation period amount component, e.g. A two month stub period may used the linear interpolation of a one month and three month floating rate. The different rate tenors would be specified in this component. Note that a maximum of two rate tenors can be specified. If a stub period uses a single index tenor and this is the same as that specified in the calculation period amount component then the initial stub or final stub component, as the case may be, must not be included.">
	[synonym FpML value StubCalculationPeriodAmount]
{
	calculationPeriodDatesReference string (1..1) reference <"A pointer style reference to the associated calculation period dates component defined elsewhere in the document.">;
		[synonym FpML value calculationPeriodDatesReference]
	initialStub StubValue (0..1) <"Specifies how the initial stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">;
		[synonym FpML value initialStub]
	finalStub StubValue (0..1) <"Specifies how the final stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">;
		[synonym FpML value finalStub]
}

/*
 * QUESTION TO CDM GROUP
 * TODO - FpML sample credit trades don't include examples that specify those attributes
 * Would be great if we could confirm the actual usage though sample transactions
 */
class TransactedPrice <"A class to represent the transacted price attributes that are positioned as part of the FpML FeeLeg.">
{
	marketFixedRate number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the credit spread ('fair value') at which the trade was executed. Unlike the fixedRate of an index, the marketFixedRate varies over the life of the index depending on market conditions. The marketFixedRate is the price of the index as quoted by trading desks.">;
		[synonym FpML value marketFixedRate pathExpression "feeLeg"]
	initialPoints number (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">;
		[synonym FpML value initialPoints pathExpression "feeLeg"]
	marketPrice number (0..1) <"An optional element that only has meaning in a credit index trade. This element contains the price at which the trade was executed and is used instead of marketFixedRate on credit trades on certain indicies which are quoted using a price rather than a spread.">;
		[synonym FpML value marketPrice pathExpression "feeLeg"]
	quotationStyle QuotationStyleEnum (0..1) <"An optional element that contains the up-front points expressed as a percentage of the notional. An initialPoints value of 5% would be represented as 0.05. The initialPoints element is an alternative to marketFixedRate in quoting the traded level of a trade. When initialPoints is used, the traded level is the sum of fixedRate and initialPoints. The initialPoints is one of the items that are factored into the initialPayment calculation and is payable by the Buyer to the Seller. Note that initialPoints and marketFixedRate may both be present in the same document when both implied values are desired.">;
		[synonym FpML value quotationStyle pathExpression "feeLeg"]
}

data rule TransactedPrice_marketPrice <"FpML specifies that  marketFixedRate and marketPrice only have meaning in a credit index trade">
	when Payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation is absent
	then Payout -> creditDefaultPayout -> transactedPrice -> marketFixedRate is absent
		and Payout -> creditDefaultPayout -> transactedPrice -> marketPrice is absent

isProduct InterestRate_IRSwap_Basis
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Basis]
	[synonym Bank_A value BasisSwap] // The purpose is to illustrate how firms could map to their own internal product identification
	[synonym Venue_B value FloatFloatInterestSwap]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists

isProduct InterestRate_IRSwap_FixedFloat
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists

isProduct InterestRate_IRSwap_FixedFixed
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFixed]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists

isProduct InterestRate_CrossCurrency_Basis
	[synonym ISDA_Taxonomy_v1 value InterestRate_CrossCurrency_Basis]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists

isProduct InterestRate_CrossCurrency_FixedFloat
	[synonym ISDA_Taxonomy_v1 value InterestRate_CrossCurrency_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists

isProduct InterestRate_IRSwap_FixedFloat_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat] // The v1 taxonomy doesn't have this v2 level of detail
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T

isProduct InterestRate_IRSwap_FixedFloat_PlainVanilla
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat] // The v1 taxonomy doesn't have this v2 level of detail
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> spreadSchedule -> step is absent
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateMultiplierSchedule is absent
/*
 * TODO - Cannot compare the below because in FpML the period associated with the reset frequency is of type PeriodExtendedEnum, which includes 'T'
 * Need to adjust the implementation once a proper implementation approach has been firmed out
 */
//	and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period =
//		EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> indexTenor -> period
	and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier =
		EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> indexTenor -> periodMultiplier
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum.T
	and ( 
		// Payment frequency = reset frequency 
		( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 
		EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier
		and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = 
			EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period )
		// Payment frequency is annual and reset frequency is semi-annual and compounding does not apply
		// Payment frequency is annual and reset frequency is quarterly and compounding does not apply
		or ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y 
			and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum.M
				and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 6 
					or EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3 )
				and EconomicTerms -> payout -> interestRatePayout -> compoundingMethod is absent )
		// Payment frequency is semi annual and reset frequency is quarterly and compounding does not apply
		// Payment frequency is quarterly and reset frequency is monthly and compounding does not apply
		or ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.M 
			and ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 6 
				or EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 3 )
			and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum.M
				and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3 )
				and EconomicTerms -> payout -> interestRatePayout -> compoundingMethod is absent ) ) )
	// Not able to represent the clause 'No provision for early termination which uses an off-market valuation'

/*
 * TODO Adjust the Xtext grammar to support enumeration styles
 */
isProduct InterestRate_IRSwap_FixedFloat_OIS
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateIndex = FloatingRateIndexEnum.AUD_AONIA_OIS_COMPOUND

isProduct InterestRate_IRSwap_Basis_OIS
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Basis]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateIndex = FloatingRateIndexEnum.AUD_AONIA_OIS_COMPOUND
	
isProduct InterestRate_InflationSwap_FixedFloat_YearOn_Year
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y

isProduct InterestRate_InflationSwap_FixedFloat_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T

isProduct InterestRate_InflationSwap_Basis_YearOn_Year
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y

isProduct InterestRate_InflationSwap_Basis_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T

isProduct InterestRate_Option_Swaption
	[synonym ISDA_Taxonomy_v1 value InterestRate_Option_Swaption]
	EconomicTerms -> payout -> optionPayout exists
	and EconomicTerms -> payout -> optionPayout -> underlyer -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists
	and EconomicTerms -> payout -> optionPayout -> underlyer -> contractualProduct -> economicTerms -> payout -> interestRatePayout exists

isProduct InterestRate_Option_DebtOption
	[synonym ISDA_Taxonomy_v1 value InterestRate_DebtOption]
	EconomicTerms -> payout -> optionPayout -> underlyer -> listedProduct -> bond exists
		or EconomicTerms -> payout -> optionPayout -> underlyer -> listedProduct -> convertibleBond exists
			
/*
 * QUESTION TO CDM GROUP
 * TODO - How do we identify specify the CDS products, in the absence of normalised scheme values?
 */
