Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

/*
 * PRODUCT COMPOSITE APPROACH
 * The product is dynamically inferred from the economic terms, based upon a set of definitions that are associated to the model
 * As part of it, we are looking to converge the data presentation of IRD and CDS products, while still making use of the FpML building blocks
 */
 
class Contract <"A class to specify a contract object, which can be invoked either within the context of an event, or independently from it. It corresponds to the FpML Trade, although restricted to execution and post-execution contexts. Attributes also applicable to pre-execution (a.k.a. pre-trade view in FpML) contexts have been positioned as part of the ContractualProduct class.">
{
	contractIdentifier PartyContractIdentifier (1..*) <"The contract reference identifier(s) allocated by the parties involved in the contract.">;
		[synonym FpML value partyTradeIdentifier pathExpression "trade.tradeHeader"] 
	tradeDate date (1..1) <"The trade date. This is the date the trade was originally executed. In the case of a novation, the novated part of the trade should be reported (by both the remaining party and the transferee) using a trade date corresponding to the date the novation was agreed. The remaining part of a trade should be reported (by both the transferor and the remaining party) using a trade date corresponding to the original execution date.">;
		[synonym FpML value tradeDate pathExpression "trade.tradeHeader"]
	clearedDate date (0..1) anchor <"If the trade was cleared (novated) through a central counterparty clearing service, this represents the date the trade was cleared (transferred to the central counterparty).">;
		[synonym FpML value clearedDate pathExpression "trade.tradeHeader"]
	contractualProduct ContractualProduct (1..1) <"The contractual product information that is associated with the contract. The corresponding FpML construct is the product abstract element and the associated substitution group.">;
	otherPartyPayment Payment (0..*) <"Other fees or additional payments associated with the contract, e.g. broker commissions, where one or more of the parties involved are not principal parties involved in the contract.">;
		[synonym FpML value otherPartyPayment pathExpression "trade"]
	brokerParty Party (0..*) reference <"The party (or parties) that brokered the contract.">;
		[synonym FpML value brokerPartyReference pathExpression "trade"]	
	calculationAgent CalculationAgentModel (1..1) <"The ISDA Calculation Agent and the associated business center information. This information is represented in FpML via the CalculationAgent.model.">;
	determiningParty Party (0..2) reference <"The ISDA Determination Party that is specified in the related confirmation as Determination Party.">;
		[synonym FpML value determiningParty pathExpression "trade"]
	barrierDeterminationAgent Party (0..1) reference <"The party specified in the related confirmation as Barrier Determination Agent.">;
		[synonym FpML value barrierDeterminationAgent pathExpression "trade"]
	hedgingParty Party (0..2) reference <"The ISDA Hedging Party that is specified in the related confirmation as Hedging, or if no Hedging Party is specified, either party to the contract.">;
		[synonym FpML value hedgingParty pathExpression "trade"]
	collateral Collateral (0..1) <"Defines the collateral obligations of a party.">;
		[synonym FpML value collateral pathExpression "trade"]
	documentation Documentation (0..1) <"Defines the definitions that govern the document and should include the year and type of definitions referenced, along with any relevant documentation (such as master agreement) and the date it was signed.">;
		[synonym FpML value documentation pathExpression "trade"]
	governingLaw GoverningLawEnum (0..1) <"Identification of the law governing the transaction.">;
		[synonym FpML value governingLaw pathExpression "trade"]
	/*
	 * QUESTION TO CDM GROUP
	 * TODO - Need to confirm whether we want to associate a contractState attribute.
	 * One of the objection raised in a meeting was the fact that open/close is too simplistic as a state.
	 * Should we look to enhance the indicator with an associated qualifier, e.g. Legal, Accounting?
	 * Or should we drop this concept for the time being?
	 */
	contractState ContractStateEnum (0..1) <"The state qualification of a contractual product, i.e. whether open or close. This attribute is not present as part of the FpML standard.">;
	party Party (2..*) <"The parties to the contract. While FpML has a minimal cardinality of 1, a minimal cardinality of 2 seems more appropriate.">;
}

data rule Contract_clearedDate
	when Contract -> clearedDate exists
	then Contract -> clearedDate >= Contract -> tradeDate

class ContractualProduct <"The contractual product class is meant to be used across the entire pre-execution, execution and (as part of the Contract) post-execution lifecycle contexts.">
{
	productIdentification string (1..1) isProduct;
	productTaxonomy ProductTaxonomy (1..*) <"The product taxonomy value(s) associated with a contractual product.">;
	economicTerms EconomicTerms (1..1);
}

isProduct InterestRate_IRSwap_Basis
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Basis]
	[synonym Bank_A value BasisSwap] // The purpose is to illustrate how firms could map to their own internal product identification
	[synonym Venue_B value FloatFloatInterestSwap]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists

isProduct InterestRate_IRSwap_FixedFloat
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists

isProduct InterestRate_IRSwap_FixedFixed
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFixed]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists

/*
 * TODO - Need to adjust the grammar to support values that make use of characters which are invalid according to the grammar.
 * This will require to move to a string format.
 */

isProduct InterestRate_CrossCurrency_Basis
	[synonym ISDA_Taxonomy_v1 value InterestRate_CrossCurrency_Basis]
//	[synonym Rosetta_Workbench value InterestRate:CrossCurrency:Basis] 
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists

isProduct InterestRate_CrossCurrency_FixedFloat
	[synonym ISDA_Taxonomy_v1 value InterestRate_CrossCurrency_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> crossCurrencyTerms -> principalExchanges exists

isProduct InterestRate_IRSwap_FixedFloat_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat] // The v1 taxonomy doesn't have this v2 level of detail
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T

isProduct InterestRate_IRSwap_FixedFloat_PlainVanilla
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat] // The v1 taxonomy doesn't have this v2 level of detail
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> spreadSchedule -> step is absent
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateMultiplierSchedule is absent
/*
 * TODO - Cannot compare the below because in FpML the period associated with the reset frequency is of type PeriodExtendedEnum, which includes 'T'
 * Need to adjust the implementation once a proper implementation approach has been firmed out
 */
//	and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period =
//		EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> indexTenor -> period
	and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier =
		EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> indexTenor -> periodMultiplier
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period <> PeriodExtendedEnum.T
	and ( 
		// Payment frequency = reset frequency 
		( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 
		EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier
		and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = 
			EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period )
		// Payment frequency is annual and reset frequency is semi-annual and compounding does not apply
		// Payment frequency is annual and reset frequency is quarterly and compounding does not apply
		or ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y 
			and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum.M
				and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 6 
					or EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3 )
				and EconomicTerms -> payout -> interestRatePayout -> compoundingMethod is absent )
		// Payment frequency is semi annual and reset frequency is quarterly and compounding does not apply
		// Payment frequency is quarterly and reset frequency is monthly and compounding does not apply
		or ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.M 
			and ( EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 6 
				or EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 3 )
			and ( EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> period = PeriodExtendedEnum.M
				and EconomicTerms -> payout -> interestRatePayout -> resetDates -> resetFrequency -> periodMultiplier = 3 )
				and EconomicTerms -> payout -> interestRatePayout -> compoundingMethod is absent ) ) )
	// Not able to represent the clause 'No provision for early termination which uses an off-market valuation'

/*
 * TODO Adjust the Xtext grammar to support enumeration styles
 */
isProduct InterestRate_IRSwap_FixedFloat_OIS
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_FixedFloat]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateIndex = FloatingRateIndexEnum.AUD_AONIA_OIS_COMPOUND

isProduct InterestRate_IRSwap_Basis_OIS
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Basis]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate -> floatingRateIndex = FloatingRateIndexEnum.AUD_AONIA_OIS_COMPOUND
	
isProduct InterestRate_InflationSwap_FixedFloat_YearOn_Year
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y

isProduct InterestRate_InflationSwap_FixedFloat_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T

isProduct InterestRate_InflationSwap_Basis_YearOn_Year
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and 	EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.Y

isProduct InterestRate_InflationSwap_Basis_ZeroCoupon
	[synonym ISDA_Taxonomy_v1 value InterestRate_IRSwap_Inflation]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate exists
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate exists
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = 1
	and EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency -> period = PeriodExtendedEnum.T


/*
 * QUESTION TO CDM GROUP
 * TODO - How do we identify specify the CDS products, in the absence of normalised scheme values?
 */

class EconomicTerms <"This class represents the full set of product economics: the payout component, as well as the legal optional provisions which have valuation implications.">
{
	payout Payout (1..1) <"The payout specification, which can combine several payout terms, e.g. an interest rate and a credit default payout in the case of a credit default swap.">;
	earlyTerminationProvision EarlyTerminationProvision (0..1) <"Parameters specifying provisions relating to the optional and mandatory early termination of a swap transaction.">;
		[synonym FpML value earlyTerminationProvision pathExpression "trade.swap"]
	cancelableProvision CancelableProvision (0..1) <"A provision that allows the specification of an embedded option within a swap giving the buyer of the option the right to terminate the swap, in whole or in part, on the early termination date.">;
		[synonym FpML value cancelableProvision pathExpression "trade.swap"]
	extendibleProvision ExtendibleProvision (0..1) <"A provision that allows the specification of an embedded option with a swap giving the buyer of the option the right to extend the swap, in whole or in part, to the extended termination date.">;
}

class Payout <"The payout can be specified through a number of combinations, e.g. by associating several interest rate payouts to specify an interest rate swap, or a credit default and an interest rate payout to specify a credit default swap. The implied product is inferred by the isProduct CDM artefact.">
{
	interestRatePayout InterestRatePayout (0..*);
		[synonym FpML value swapStream pathExpression "trade.swap"]
		[synonym FpML value feeLeg pathExpression "trade.creditDefaultSwap"]
		[synonym FpML value generalTerms pathExpression "trade.creditDefaultSwap"]
	creditDefaultPayout CreditDefaultPayout (0..1);
	fee Payment (0..*) <"A payment between the parties to the trade. For interest rate products, this corresponds to the FpML additionalPayment element. For credit default swaps, this corresponds to the initialPayment element.">;
		[synonym FpML value additionalPayment pathExpression "trade.swap"]
		[synonym FpML value initialPayment pathExpression "trade.creditDefaultSwap.feeLeg"]
}

/*
 * TODO - Need to cross-reference the 2014 credit definitions when relevant. 
 * (FpML schema has not been updated to reflect those definitions.)
 */
class InterestRatePayout calculation FixedAmount <"The interest rate payout specification terms.">
{
	payerParty Party (1..1) reference <"The payer party. While FpML specifies it as an href into one of the parties, Rosetta specifies the party, to enhance clarity and legibility.">;
		[synonym FpML value payerPartyReference]
	receiverParty Party (1..1) reference <"The receiver party.  While FpML specifies it as an href into one of the parties, Rosetta specifies the party, to enhance clarity and legibility.">;
		[synonym FpML value receiverPartyReference]
	quantity ContractualQuantity (1..1) <"The quantity can be expressed in different formats, depending upon the product, e.g. notional amount for credit and interest rate products, quantity for some of the equity products. The CDM uses the generic term quantity rather than notional amount.">;
	interestRate InterestRate (0..1) <"The interest rate can be a floating rate, a fixed rate of an inflation rate.">;
	dayCountFraction DayCountFractionEnum (1..1) <"The day count fraction.">;
		[synonym FpML value dayCountFraction pathExpression "calculationPeriodAmount.calculation"]
		[synonym FpML value dayCountFraction pathExpression "periodicPayment.fixedAmountCalculation"]
		[synonym FpML value dayCountFraction pathExpression "periodicPayment.floatingAmountCalculation"]
	discounting Discounting (0..1) <"The parameters specifying any discounting conventions that may apply. This element must only be included if discounting applies.">;
		[synonym FpML value discounting pathExpression "calculationPeriodAmount.calculation"]
	compoundingMethod CompoundingMethodEnum (0..1) <"If one or more calculation period contributes to a single payment amount this element specifies whether compounding is applicable and, if so, what compounding method is to be used. This element must only be included when more than one calculation period contributes to a single payment amount.">;
		[synonym FpML value compoundingMethod pathExpression "calculationPeriodAmount.calculation"]
	calculationPeriodDates CalculationPeriodDates (1..1) <"The calculation period dates schedule.">;
	paymentDates PaymentDates (1..1) <"The payment dates schedule.">;
		[synonym FpML value paymentDates]
		[synonym FpML value periodicPayment]
	resetDates ResetDates (1..1) <"The reset dates schedule. The reset dates schedule only applies for a floating rate stream.">;
		[synonym FpML value resetDates]
	cashflows Cashflows (0..1) <"The cashflow representation of the swap stream.">;
		[synonym FpML value cashflows]
	crossCurrencyTerms CrossCurrencyTerms (0..1) <"The specification of the principle exchange and settlement provision terms.">;
	stubPeriod StubPeriod (0..1) <"The stub calculation period amount parameters. This element must only be included if there is an initial or final stub calculation period. Even then, it must only be included if either the stub references a different floating rate tenor to the regular calculation periods, or if the stub is calculated as a linear interpolation of two different floating rate tenors, or if a specific stub rate or stub amount has been negotiated.">;
		[synonym FpML value StubCalculationPeriodAmount]
}

data rule CompoundingMethod_absent <"Compounding method is prohibited when the calculation period and the payment frequencies are the same. This data rule implements the FpML validation rule ird-7.">
 	when InterestRatePayout -> paymentDates -> paymentFrequency -> period = InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		and InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier = InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier
 	then InterestRatePayout -> compoundingMethod is absent
 	
data rule CompoundingMethod_present <"Compounding method is required when the calculation-period and payment frequencies differ. This data rule implements the FpML validation rule ird-7.">
 	when (InterestRatePayout -> paymentDates -> paymentFrequency -> period <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		and InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
 	or (InterestRatePayout -> paymentDates -> paymentFrequency -> period <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> period
 		or InterestRatePayout -> paymentDates -> paymentFrequency -> periodMultiplier <> InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
 	then InterestRatePayout -> compoundingMethod exists

data rule CompoundingMethod_resetDates <"Compounding method must be associated with the presence of reset dates. This data rule implements the FpML validation rule ird-9.">
	when InterestRatePayout -> compoundingMethod exists
	then InterestRatePayout -> resetDates exists

data rule CompoundingMethod_fixedRate <"Compounding method exists is prohibited when the fixed rate applies. This data rule implements the FpML validation rule ird-29. ">
	when InterestRatePayout -> compoundingMethod exists
	then InterestRatePayout -> interestRate -> fixedRate is absent

data rule InterestRatePayout_quantity <"The quantity associated to an interest rate payout should not be expressed as a quantity, but rather as a notional.">
	when InterestRatePayout exists
	then InterestRatePayout -> quantity -> quantity is absent

class StubPeriod <"A class defining how the initial or final stub calculation period amounts is calculated. For example, the rate to be applied to the initial or final stub calculation period may be the linear interpolation of two different tenors for the floating rate index specified in the calculation period amount component, e.g. A two month stub period may used the linear interpolation of a one month and three month floating rate. The different rate tenors would be specified in this component. Note that a maximum of two rate tenors can be specified. If a stub period uses a single index tenor and this is the same as that specified in the calculation period amount component then the initial stub or final stub component, as the case may be, must not be included.">
	[synonym FpML value StubCalculationPeriodAmount]
{
	calculationPeriodDates CalculationPeriodDates (1..1) reference <"The associated calculation period dates. In the FpML standard, this is implemented as an href pointer. For clarity and legibility purposes, Rosetta specifies the actual calculation period dates, while keeping the href information for audit trail purposes.">;
		[synonym FpML value calculationPeriodDatesReference]
	initialStub StubValue (0..1) <"Specifies how the initial stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">;
		[synonym FpML value initialStub]
	finalStub StubValue (0..1) <"Specifies how the final stub amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating tenors may be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3. Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.">;
		[synonym FpML value finalStub]
}

/*
 * QUESTION TO CDM GROUP
 * FpML CDS include 2 calculationAmount elements: (i) at the feeLeg/periodPayment level for both the fixedAmount and the floatingAmount calculation, 
 * where the definition references in both cases the ISDA 2003 Term: Fixed Rate Payer Calculation Amount, and (ii) at the protectionTerms level,
 * where the definition references the ISDA 2003 Term: Floating Rate Payer Calculation Amount.
 * The CDM provides those 2 notional amounts.  Do we have situations in which those amounts are different?  If not, should we look to collapse those?
 */

class ContractualQuantity
{
	quantity Quantity (0..1);
	notionalAmount Money (0..1) <"When applied to Credit default Swaps, this is the notional amount of protection coverage. ISDA 2003 Term: Floating Rate Payer Calculation Amount">;
		[synonym FpML value initialValue pathExpression "calculationPeriodAmount.calculation" set notionalAmount when notionalSchedule -> notionalStepSchedule -> step is absent]
		[synonym FpML value calculationAmount pathExpression "periodicPayment.fixedAmountCalculation"]
		[synonym FpML value calculationAmount pathExpression "periodicPayment.floatingAmountCalculation"]
		[synonym Rosetta_Workbench value notionalAmount]
	notionalSchedule NotionalSchedule (0..1);
		[synonym FpML value notionalSchedule pathExpression "calculationPeriodAmount.calculation" set notionalSchedule when notionalSchedule -> notionalStepSchedule -> step exists]
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
		[synonym FpML value fxLinkedNotionalSchedule pathExpression "calculationPeriodAmount.calculation" set notionalSchedule when fxLinkedNotional -> initialValue exists ]
	futureValueNotional FutureValueAmount (0..1);
	 	[synonym FpML value futureValueNotional pathExpression "calculationPeriodAmount.calculation"]
}

choice rule ContractualQuantity_choice <"TThe below set of notional values are exclusive, while some of those could be associated with the futureValueNotional.">
	for ContractualQuantity optional choice between
	quantity and notionalAmount and notionalSchedule and fxLinkedNotional

data rule InterestRatePayout_futureValueNotional <"The BRL CDI future value notional only applies to a fixed Rate Schedule.">
	when InterestRatePayout -> interestRate -> fixedRate is absent
	then InterestRatePayout -> quantity -> futureValueNotional is absent

data rule FutureValueNotional_terminationDate <"FpML states that the value date associated with the future value notional should match the adjusted termination date.">
	when InterestRatePayout -> quantity -> futureValueNotional exists
	then InterestRatePayout -> quantity -> futureValueNotional -> valueDate = InterestRatePayout -> calculationPeriodDates -> terminationDate -> adjustedDate

class NotionalSchedule
	[synonym FpML value Notional]
{
	id string (0..1);
		[synonym FpML value id]
	notionalStepSchedule NonNegativeAmountSchedule (1..1) <"The notional amount or notional amount schedule expressed as explicit outstanding notional amounts and dates. In the case of a schedule, the step dates may be subject to adjustments in accordance with any adjustments specified in calculationPeriodDatesAdjustments.">;
		[synonym FpML value notionalStepSchedule]
	notionalStepParameters NotionalStepRule (0..1) <"A parametric representation of the notional step schedule, i.e. parameters used to generate the notional schedule.">;
		[synonym FpML value notionalStepParameters]
}

data rule NotionalSchedule_notionalStepSchedule <"FpML validation rule ird-61 - Context: NonNegativeSchedule (complex type). If step does not exist, then initialValue must not be equal to 0.">
	when NotionalSchedule -> notionalStepSchedule -> step is absent
	then NotionalSchedule -> notionalStepSchedule -> initialValue <> 0b

/*
 * The mapping to the CDS feeLeg is handled at a lower granularity level because the overall construct is different
 */
class InterestRate one of
{
	fixedRate Schedule (0..1);
		[synonym FpML value fixedRateSchedule pathExpression "calculationPeriodAmount.calculation"]
	floatingRate FloatingRateCalculation (0..1);
		[synonym FpML value floatingRateCalculation pathExpression "calculationPeriodAmount.calculation"]
	inflationRate InflationRateCalculation (0..1);
		[synonym FpML value inflationRateCalculation pathExpression "calculationPeriodAmount.calculation"]
}

class CreditDefaultPayout <"The credit default payout specification terms.">
{
	generalTerms GeneralTerms (1..1);
	protectionTerms ProtectionTerms (1..1);
		[synonym FpML value protectionTerms pathExpression "trade.creditDefaultSwap"]
	cashSettlementTerms CashSettlementTerms (0..1);
		[synonym FpML value cashSettlementTerms pathExpression "trade.creditDefaultSwap"]
	physicalSettlementTerms PhysicalSettlementTerms (0..1);
		[synonym FpML value physicalSettlementTerms pathExpression "trade.creditDefaultSwap"]
}

choice rule CreditDefaultPayout_choice <"Choice rule to represent an FpML choice construct.">
	for CreditDefaultPayout optional choice between
	cashSettlementTerms and physicalSettlementTerms

data rule CreditDefaultPayout_quantity
	when InterestRatePayout exists
	then InterestRatePayout -> quantity -> notionalAmount exists

data rule CreditDefaultPayout_inflationRate // Do we want to actually have such restriction?  While FpML does't support it, FpML scope is limited to standardised products.
	when EconomicTerms -> payout -> creditDefaultPayout exists
	then EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate is absent

class PaymentDates // Differences with the FpML PaymentDate include addition of CDS paymentDelay element.
{
	paymentFrequency Frequency (1..1);
		[synonym FpML value paymentFrequency]
	firstPaymentDate date (0..1);
		[synonym FpML value firstPaymentDate]
	lastRegularPaymentDate date (0..1);
		[synonym FpML value lastRegularPaymentDate]
	payRelativeTo PayRelativeToEnum (1..1);
		[synonym FpML value payRelativeTo]
	paymentDaysOffset Offset (0..1);
		[synonym FpML value paymentDaysOffset]
	paymentDatesAdjustments BusinessDayAdjustments (1..1);
		[synonym FpML value paymentDatesAdjustments]
	paymentDelay boolean (1..1); // As a departure from FpML, the proposal is to remove optional cardinality in a boolean attribute
		[synonym FpML value paymentDelay]
//		TODO - The below logic could be a proper way to handle the FpML optional boolean that is quite frequent in the FpML Credit schema
//		[synonym FpML value paymentDelay set paymentDelay to False when synonym is absent]
}

data rule PaymentDates_firstPaymentDate <"FpML validation rule ird-6 - Context: InterestRateStream (complex type). If paymentDates/firstPaymentDate exists, and if calculationPeriodDates/effectiveDate exists, then paymentDates/firstPaymentDate must be after calculationPeriodDates/effectiveDate/unadjustedDate.">
	when InterestRateStream -> paymentDates -> firstPaymentDate exists 
		and InterestRateStream -> calculationPeriodDates -> effectiveDate exists
	then InterestRateStream -> paymentDates -> firstPaymentDate > InterestRateStream -> calculationPeriodDates -> effectiveDate -> unadjustedDate

data rule PaymentDates_firstPaymentDate_lastRegularPaymentDate <"FpML validation rule ird-35 - Context: PaymentDates (complex type). If firstPaymentDate exists, and if lastRegularPaymentDate exists, then firstPaymentDate must be before lastRegularPaymentDate.">
	when PaymentDates -> firstPaymentDate exists 
		and PaymentDates -> lastRegularPaymentDate exists
	then PaymentDates -> firstPaymentDate < PaymentDates -> lastRegularPaymentDate

data rule PaymentDates_firstPaymentDate_initialStub <"FpML specifies that firstPaymentDate must only be included if there is an initial stub.">
	when InterestRateStream -> stubCalculationPeriodAmount -> initialStub is absent
	then InterestRateStream -> paymentDates -> firstPaymentDate is absent 

data rule PaymentDates_lastRegularPaymentDate_finalStub <"FpML specifies that lastRegularPaymentDate must only be included if there is an final stub.">
	when InterestRateStream -> stubCalculationPeriodAmount -> finalStub is absent
	then InterestRateStream -> paymentDates -> lastRegularPaymentDate is absent
	
data rule PaymentDates_paymentDaysOffset <"FpML specifies that paymentDaysOffset should only be included if early or delayed payment is applicable, i.e. if the periodMultiplier element value is not equal to zero.">
	when PaymentDates -> paymentDaysOffset exists
	then PaymentDates -> paymentDaysOffset -> periodMultiplier <> 0

class Quantity
{
	amount number (1..1);
	unitOfMeasure UnitOfMeasureEnum (0..1);
	timeUnit TimeUnitEnum (0..1);
}

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
		[synonym FpML value principalExchanges]
	settlementProvision SettlementProvision (0..1);
		[synonym FpML value settlementProvision]
}

class TransactedPrice // These are the set of transacted price attributes currently positioned as part of the FpML FeeLeg construct.
{
	marketFixedRate number (0..1);
		[synonym FpML value marketFixedRate pathExpression "feeLeg"]
	initialPoints number (0..1);
		[synonym FpML value initialPoints pathExpression "feeLeg"]
	marketPrice number (0..1);
		[synonym FpML value marketPrice pathExpression "feeLeg"]
	quotationStyle QuotationStyleEnum (0..1);
		[synonym FpML value quotationStyle pathExpression "feeLeg"]
}

class GeneralTerms // Adjusted from the FpML construct by removing the effectiveDate, terminationDate, dateAdjustments
{
	buyerSeller BuyerSeller (1..1);
	dateAdjustments BusinessDayAdjustments (0..1) <"ISDA 2003 Terms: Business Day and Business Day Convention.">;
		[synonym FpML value dateAdjustments pathExpression "trade.creditDefaultSwap.generalTerms"]
	referenceInformation ReferenceInformation (0..1);
		[synonym FpML value referenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]
	indexReferenceInformation IndexReferenceInformation (0..1);
		[synonym FpML value indexReferenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]
	basketReferenceInformation BasketReferenceInformation (0..1);
		[synonym FpML value basketReferenceInformation pathExpression "trade.creditDefaultSwap.generalTerms"]	
	additionalTerm string (0..*) scheme "additionalTermScheme";
		[synonym FpML value additionalTerm pathExpression "trade.creditDefaultSwap.generalTerms"]
	substitution boolean (1..1); // As a departure from FpML, the proposal is to remove optional cardinality in a boolean attribute. See class PaymentDates for proposed resolution.
		[synonym FpML value substitution pathExpression "trade.creditDefaultSwap.generalTerms"]
	modifiedEquityDelivery boolean (1..1); // As a departure from FpML, the proposal is to remove optional cardinality in a boolean attribute. See class PaymentDates for proposed resolution.
		[synonym FpML value modifiedEquityDelivery pathExpression "trade.creditDefaultSwap.generalTerms"]
}

choice rule GeneralTerms_choice
	for GeneralTerms required choice between
	referenceInformation and indexReferenceInformation and basketReferenceInformation
