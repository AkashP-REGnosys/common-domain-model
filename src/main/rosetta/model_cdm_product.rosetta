Rosetta versionNumber "0.0.1"
FIX versionNumber "5.0 SP3"
FpML versionNumber "5.10"

calculation FixedAmount <"2006 ISDA Definition Article 4 Section 4.4 'Fixed Amount' means, in respect of a Swap Transaction and a Fixed Rate Payer, an amount that, subject to any other applicable provisions, is payable by that Fixed Rate Payer on an applicable Payment Date and is specified in the related Confirmation or is determined as provided in Article 5 of these 2006 Definitions or as provided in the related Confirmation."> {
	fixedAmount bigDecimal: amount * fixedRate * dayCountFraction  
	currency CurrencyEnum: currency
}

arguments FixedAmount {
	amount: is EconomicTerms -> quantity -> notional -> notionalStepSchedule -> initialValue
	currency: is EconomicTerms -> quantity -> notional -> notionalStepSchedule -> currency
	fixedRate: is EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate -> initialValue
    dayCountFraction: is EconomicTerms -> payout -> interestRatePayout -> dayCountFraction
}

calculation DayCountFractionEnum_30E_360 <"Annex 2006 ISDA Definition Article 4 section 4.16(g) [[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360"> {
	bigDecimal: (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360
}

/**
 *	Y1 - the year in which the 1st day of the Calculation/Compounding Period falls
 *	Y2 - the year in which the day immediately following the last day of the Calculation/Compounding Period falls 
 *	M1 - the month in which the 1st day of the Calculation/Compounding Period falls
 *	M2 - the month in which the day immediately following the last day of the Calculation/Compounding Period falls
 *	D1 - the 1st calendar day of the Calculation/Compounding Period (if 31, D1 will be 30)
 *	D2 - the calendar day immediately following the last day of the Calculation/Compounding Period (if 31, D2 will be 30)
 */
arguments DayCountFractionEnum_30E_360 {
	alias period CalculationPeriod()
	
	endYear : is period -> endDate -> year
	startYear : is period -> startDate -> year
	endMonth : is period -> endDate -> month
	startMonth : is period -> startDate -> month
	startDay : is Min(period -> startDate -> day, 30.0)
	endDay : is Min(period -> endDate -> day + 1, 30.0)
}

calculation CalculationPeriod <"Annex 2006 ISDA Definition Article 4 Section 4.13 'Calculation Period' means, in respect of a Swap Transaction and a party, each period from, and including, one Period End Date of that party to, but excluding, the next following applicable Period End Date during the Term of the Swap Transaction, except that (a) the initial Calculation Period for the party will commence on, and include, the Effective Date and (b) the final Calculation Period for the party will end on, but exclude, the Termination Date."> {
	dateRange : Within(AllCalculationPeriods(), currentPeriodDate)
}

arguments CalculationPeriod {
	currentPeriodDate: is EconomicTerms -> payout -> interestRatePayout -> paymentDates -> firstPaymentDate // -> unknown how we get this at the moment. 
}

// calculate all periods from effective date to term date
calculation AllCalculationPeriods {	
	dateRange : DateRanges(Adjust(effectiveDate), Adjust(terminationDate), paymentFrequency)
}

arguments AllCalculationPeriods {
	effectiveDate: is EconomicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate
	terminationDate: is EconomicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> terminationDate
	paymentFrequency: is EconomicTerms -> payout -> interestRatePayout -> paymentDates -> paymentFrequency // TODO this should be a record Type
}


/*
 * PRODUCT COMPOSITE APPROACH
 * The product is dynamically inferred from the economic terms, based upon a set of definitions that are associated to the model
 * As part of it, we are looking to converge the data presentation of IRD and CDS products, while still making use of the FpML building blocks
 */
 
class Contract <"A class to specify a contract object, which can be invoked either within the context of an event, or independently from it. It corresponds to the FpML Trade, although restricted to execution and post-execution contexts. Attributes also applicable to pre-execution (a.k.a. pre-trade view in FpML) contexts have been positioned as part of the ContractualProduct class.">
	[synonym FpML value Trade]
{
	contractIdentifier PartyTradeIdentifier (1..*) <"The contract reference identifier(s) allocated by the parties involved in the contract.">;
		[synonym FpML value partyTradeIdentifier pathExpression "trade.tradeHeader"] 
	tradeDate date (1..1) <"The trade date. This is the date the trade was originally executed. In the case of a novation, the novated part of the trade should be reported (by both the remaining party and the transferee) using a trade date corresponding to the date the novation was agreed. The remaining part of a trade should be reported (by both the transferor and the remaining party) using a trade date corresponding to the original execution date.">;
		[synonym FpML value tradeDate pathExpression "trade.tradeHeader"]
	clearedDate date (0..1) anchor <"If the trade was cleared (novated) through a central counterparty clearing service, this represents the date the trade was cleared (transferred to the central counterparty).">;
		[synonym FpML value clearedDate pathExpression "trade.tradeHeader"]
	contractualProduct ContractualProduct (1..1) <"The contractual product information that is associated with the contract. The corresponding FpML construct is the product abstract element and the associated substitution group.">;
	otherPartyPayment Payment (0..*) <"Other fees or additional payments associated with the contract, e.g. broker commissions, where one or more of the parties involved are not principal parties involved in the contract.">;
		[synonym FpML value otherPartyPayment pathExpression "trade"]
	brokerParty Party (0..*) reference <"The party (or parties) that brokered the contract. In FpML, this element is specified as a reference to a party.">;
		[synonym FpML value brokerPartyReference pathExpression "trade"]	
	calculationAgent CalculationAgentModel (1..1) <"The ISDA Calculation Agent and the associated business center information. This information is represented in FpML via the CalculationAgent.model.">;
	determiningParty Party (0..2) reference <"The ISDA Determination Party that is specified in the related confirmation as Determination Party.">;
		[synonym FpML value determiningParty pathExpression "trade"]
	barrierDeterminationAgent Party (0..1) reference <"The party specified in the related confirmation as Barrier Determination Agent.">;
		[synonym FpML value barrierDeterminationAgent pathExpression "trade"]
	hedgingParty Party (0..2) reference <"The ISDA Hedging Party that is specified in the related confirmation as Hedging, or if no Hedging Party is specified, either party to the contract.">;
		[synonym FpML value hedgingParty pathExpression "trade"]
	collateral Collateral (0..1) <"Defines the collateral obligations of a party.">;
		[synonym FpML value collateral pathExpression "trade"]
	documentation Documentation (0..1) <"Defines the definitions that govern the document and should include the year and type of definitions referenced, along with any relevant documentation (such as master agreement) and the date it was signed.">;
		[synonym FpML value documentation pathExpression "trade"]
	governingLaw GoverningLawEnum (0..1) <"Identification of the law governing the transaction.">;
		[synonym FpML value governingLaw pathExpression "trade"]
	/*
	 * TODO - Need to confirm this new proposed attribute
	 * 	If need is confirmed, should it be positioned as part of the Documentation class?
	 */
	confirmation Confirmation (1..1) <"Specifies whether the contract is confirmed as a stand-alone component and provides a workflow indicator of its confirmation status. This component doesn't exist in FpML.">;
	/*
	 * TODO - Need to confirm whether we want to associate a contractState attribute.
	 * One of the objection raised in a meeting was the fact that open/close is too simplistic as a state.
	 * Should we look to enhance the indicator with an associated qualifier, e.g. Legal, Accounting?
	 * Or should we drop this concept for the time being?
	 */
	contractState ContractStateEnum (0..1) <"The state qualification of a contractual product, i.e. whether open or close. This attribute is not present as part of the FpML standard.">;
	/*
	 * TODO - Need to confirm whether it is OK not to include the following FpML attributes:
	 * - allocations (until such time that we work out the CDM allocation model representation)
	 * - approvals (until such time that we confirm usage by market participants)
	 */
}

data rule Contract_clearedDate
	when Contract -> clearedDate exists
	then Contract -> clearedDate >= Contract -> tradeDate

class ContractualProduct
{
	productIdentification string (1..1) isProduct; // A back-end logic associated to the isProduct qualifier will specify the product as a function of the associated economic terms
	economicTerms EconomicTerms (1..1);
}

/*
 * The below product specification reflects the ISDA Taxonomy v2.0
 */

isProduct InterestRate_IRSwap_Basis
	[synonym Bank_A value BasisSwap] // The purpose is to illustrate how firms could map to their own internal product identification
	[synonym Venue_B value FloatFloatInterestSwap]
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate

isProduct InterestRate_IRSwap_FixedFloat
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> floatingRate

isProduct InterestRate_IRSwap_FixedFixed
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate

isProduct InterestRate_InflationSwap_FixedFloat
	EconomicTerms -> payout -> interestRatePayout -> interestRate -> fixedRate
	and EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate

class EconomicTerms 
{
	payout Payout (1..1);
	earlyTerminationProvision EarlyTerminationProvision (0..1);
		[synonym FpML value earlyTerminationProvision pathExpression "trade.swap"]
	cancelableProvision CancelableProvision (0..1);
		[synonym FpML value cancelableProvision pathExpression "trade.swap"]
	extendibleProvision ExtendibleProvision (0..1);
		[synonym FpML value extendibleProvision pathExpression "trade.swap"]
}

class Payout
{
	interestRatePayout InterestRatePayout (0..*);
	creditDefaultPayout CreditDefaultPayout (0..1);
}

class InterestRatePayout
{
	payerParty Party (1..1) reference;
		[synonym FpML value payerPartyReference pathExpression "trade.swap.swapStream"]
	receiverParty Party (1..1) reference;
		[synonym FpML value receiverPartyReference pathExpression "trade.swap.swapStream"]
	notional Notional (1..1);
	interestRate InterestRate (0..1);
		
	dayCountFraction DayCountFractionEnum (1..1);
	discounting Discounting (0..1);
	compoundingMethod CompoundingMethodEnum (0..1);
	calculationPeriodDates CalculationPeriodDates (1..1);
	paymentDates PaymentDatesNew (1..1);
	resetDates ResetDates (1..1);
	crossCurrencyTerms CrossCurrencyTerms (0..1); // New construct, that wraps the principleExchanges and settlementProvision terms
}

class InterestRate one of
{
	fixedRate Schedule (0..1);
	floatingRate FloatingRateCalculation (0..1);
	inflationRate InflationRateCalculation (0..1);
}

class CreditDefaultPayout
{
	generalTerms GeneralTermsNew (1..1);
	protectionTerms ProtectionTerms (1..1);
	cashSettlementTerms CashSettlementTerms (0..1);
	physicalSettlementTerms PhysicalSettlementTerms (0..1);
}

choice rule CreditDefaultPayout_choice <"Choice rule to represent an FpML choice construct.">
	for CreditDefaultPayout optional choice between
	cashSettlementTerms and physicalSettlementTerms

data rule CreditDefaultPayout_inflationRate // Illustrative example of a data rule; do we want to actually have such restriction?  While FpML does't support it, FpML scope is limited to standardised products.
	when EconomicTerms -> payout -> creditDefaultPayout exists
	then EconomicTerms -> payout -> interestRatePayout -> interestRate -> inflationRate must be absent

class PaymentDatesNew // Differences with the FpML PaymentDate include addition of CDS paymentDelay element.
{
	/*
	 * If the CDM is meant to provide a more streamlined representation, should we look to limit the need for cross-referencing
	 * by stating that the calculation period dates, reset dates and fixing dates are those specified as part of the payout which those are part of?
	 */
//	calculationPeriodDates CalculationPeriodDates (0..1) reference;
//	resetDates ResetDates (0..1) reference;
//	valuationDates FxFixingDate (0..1) reference;
	paymentFrequency Frequency (1..1);
	firstPaymentDate date (0..1);
	lastRegularPaymentDate date (0..1);
	payRelativeTo PayRelativeToEnum (1..1);
	paymentDaysOffset Offset (0..1);
	paymentDatesAdjustments BusinessDayAdjustments (1..1);
	paymentDelay boolean (0..1);
}

class ContractualQuantity one of
{
	quantity QuantityNew (0..1);
	notional Notional (0..1);
	fxLinkedNotional FxLinkedNotionalSchedule (0..1);
}

class QuantityNew 
{
	quantity bigDecimal (1..1);
	unitOfMeasure UnitOfMeasureEnum (0..1);
	timeUnit TimeUnitEnum (0..1);
}

class CrossCurrencyTerms
{
	principalExchanges PrincipalExchanges (0..1);
	settlementProvision SettlementProvision (0..1);
}

class Confirmation // Confirmation is a new proposed model component, aimed at providing clarity with respect to the confirmation of multi-components products/strategies.
{
	multiComponentsConfirmation boolean (1..1);
	otherConfirmationComponents TradeIdentifier (0..*);
	isConfirmed boolean (1..1);
}

data rule Confirmation_otherConfirmationComponents
	when Confirmation -> isConfirmed = True
	then Confirmation -> otherConfirmationComponents must exist

class ProtectionTerms // Adjusted from the FpML construct by replacing calculationAmount, a.k.a. notional.
{
	quantity ContractualQuantity (1..1);
	creditEvents CreditEvents (0..1);
	obligations Obligations (0..1);
	floatingAmountEvents FloatingAmountEvents (0..1);
}

class TransactedPrice // These are the set of transacted price attributes currently positioned as part of the FpML FeeLeg construct.
{
	marketFixedRate bigDecimal (0..1);
	initialPoints bigDecimal (0..1);
	marketPrice bigDecimal (0..1);
	quotationStyle QuotationStyleEnum (0..1);
}

class GeneralTermsNew // Adjusted from the FpML construct by removing the effectiveDate, terminationDate, businessDayAdjustments
{
	buyerSeller BuyerSeller (1..1);
	referenceInformation ReferenceInformation (0..1);
	indexReferenceInformation IndexReferenceInformation (0..1);
	basketReferenceInformation BasketReferenceInformation (0..1);
	additionalTerm string (0..*) scheme "additionalTermScheme";
	substitution boolean (1..1); // As a change from FpML, the proposal is to remove optional cardinality in a boolean attribute
	modifiedEquityDelivery boolean (1..1); // As a change from FpML, the proposal is to remove optional cardinality in a boolean attribute
}

choice rule GeneralTermsNew_choice
	for GeneralTerms required choice between
	referenceInformation and indexReferenceInformation and basketReferenceInformation