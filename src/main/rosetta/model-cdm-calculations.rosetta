namespace "org.isda.cdm"
version "${project.version}"

/*
 * Variation Margin Mark to Market Calculation 
 * 
 * Goals:
 *   1. Describe a product agnostic mark-to-market calculation such that it can be used for Variation Margin valuation process;
 *   2. To be as transparent as possible in capturing which CDM elements are being used for the calculations.
 */


/*
 * Option 1 - A mark to market calculation for an FX Forward as provided by a member firm
 * 
 *   1. + requires minimal infrastructure work to support VG thread
 *   2. - delegates more work to the InterpolateForwardRate function, opaque usage of ForwardPayout
 *   3. - will not support other products
 * 
 * TODO: code generation to support comparison vs. enum values
 */
calculation FxMarkToMarket_1 <"Representation of sample mark to market calculation provided by a member firm.">
{
	= (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	
	where
		// calculation inputs
		quotedQuantity <"The amount of the quoted currency.">: 
			if ForwardPayout -> foreignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForwardPayout -> foreignExchange -> exchangedCurrency2 -> cashflowAmount -> amount 
			else ForwardPayout -> foreignExchange -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if ForwardPayout -> foreignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForwardPayout -> foreignExchange -> exchangedCurrency1 -> cashflowAmount -> amount 
			else ForwardPayout -> foreignExchange -> exchangedCurrency2 -> cashflowAmount -> amount
			
		interpolatedRate :
			InterpolateForwardRate( ForwardPayout ) -> result
}

function InterpolateForwardRate( forward ForwardPayout )
{
	result number;
}


/*
 * Option 2 - A mark to market calculation for an FX Forward as provided by a member firm, but providing more transparency to the inputs of the interpolation function
 * 
 *   1. + explicit in which model elements are being passed into function calls
 *   2. - will require lots of product specific logic in a calculation that should be product agnostic
 * 
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 * TODO: (non-critical) Change to use alias, so to clearly distinguish between calculation inputs and 'syntactic sugar', enforce non-calc-inputs to be alias'
 * TODO: (non-critical) SpotRate( fx ) -> rate is unnecessary, SpotRate( fx ) should be enough, as it returns only 1 value 
 */
calculation FxMarkToMarket_2 <"Representation of sample mark to market calculation provided by a member firm, providing more transparency on the parameters used to interpolate the mark to market rate.">
{	
	= (quotedQuantity / interpolatedRate - baseQuantity) * interpolatedRate
	
	where
		// variables used in the rate InterpolateFull function call, below.
		fx:
			ForwardPayout -> foreignExchange
			
		tenor:
			fx -> tenorPeriod -> periodMultiplier
			
		tenorRemaining: 
			ForwardPayout -> settlementDate - Today() -> date
			
		spotRate:
			SpotRate( fx ) -> rate
			
		forwardRate:
			ForwardRate( fx -> tenorPeriod, fx ) -> rate
		
		// actual calculation inputs
		interpolatedRate <"The interpolated rate.">: 
			Interpolate( tenor - tenorRemaining, 0, tenor, spotRate, forwardRate ) -> result
			
		quotedQuantity <"The amount of the quoted currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency2 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency1 -> cashflowAmount -> amount
			
		baseQuantity <"The amount of the base currency.">: 
			if fx -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then fx -> exchangedCurrency1 -> cashflowAmount -> amount 
			else fx -> exchangedCurrency2 -> cashflowAmount -> amount
}

function Today() <"Returns the current date of the operating system.">
{
	date date;
}

function Interpolate(x number,  xStart int, xEnd int, yStart number, yEnd number ) <"Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ([xStart, xEnd], [yStart, yEnd]), evaluated at x.">
{
	result number;	
}

function SpotRate( fx ForeignExchange ) <"An external market data lookup for the spot fx for the currency pair.">
{
	rate number;
}

function ForwardRate( tenor Period, fx ForeignExchange ) <"An external market data lookup for the forward fx rate for the currency pair, making use of the period specified on the Foreign Exchange contract.">
{
	rate number;
}


/* 
 * Option 3 - reference other calculations, potential to make calculations product agnostic
 * 
 *   1. + Mark to market calculation described in product-agnostic terms
 *   2. + Product specific logic (i.e. to extract price and quantity) are abstracted into other 'calculations' or functions
 *   3. + Price and quantity abstractions can be reused in Portfolio processing
 *   4. - More work involved upgrade syntax and code generators
 * 
 * TODO: requires support for referencing calculations from calculations
 * TODO: code generation to support comparison vs. enum values
 * TODO: code generation to support variables that reference other variables, under the hood the reference to 'fx' in 'tenor' is broken
 */
/*
calculation MarkToMarket_3 <"Representation of sample mark to market calculation provided by a member firm.">
{
		= tradedQuantity * (tradedPrice - marketPrice)
	
	where
		tradedPrice <"The amount of the quoted currency.">: 
			TradedPrice( EconomicTerms -> payout )
			
		tradedQuantity <"The amount of the base currency.">: 
			TradedQuantity( EconomicTerms -> payout )
			
		marketPrice:
			CalculateMarketPrice( ForwardPayout ) -> result
}

calculation TradedQuantity <"A calculation that takes a Payout and returns the traded quantity.">
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
		then 
			if ForeignExchange -> exchangeRate -> quotedCurrencyPair -> quoteBasis = QuoteBasisEnum.Currency2PerCurrency1 
			then ForeignExchange -> exchangedCurrency1 -> cashflowAmount -> amount 
			else ForeignExchange -> exchangedCurrency2 -> cashflowAmount -> amount
		else if  
			if Payout -> interestRatePayout -> exists 
			then Payout -> interestRatePayout -> ... -> notionalAmount
			else 0.0
		else if 
			...
}

calculation TradedPrice
{
	= 	if Payout -> forwardPayout -> foreignExchange exists 
			then Payout -> forwardPayout -> foreignExchange -> exchangeRate -> rate
		else if Payout -> interestRatePayout exists
			then 
				... 
}

calculation CalculateMarketPrice
{
	= Interpolate(x, xStart, xEnd, yStart, yEnd)
	
	where 
		tenorRemaining: 
			EconomicTerms -> payout -> forwardPayout -> settlementDate - Today() -> date
			
		tenor:
			Tenor( EconomicTerms )
			
		x: 
			tenor - tenorRemaining
			
		xStart:
			0
			
		xEnd:
			tenor
			
		yStart:
			ForwardRate( ForwardPayout -> foreignExchange -> tenorPeriod, ForwardPayout -> foreignExchange ) -> rate
			
		yEnd:
			SpotRate( ForwardPayout -> foreignExchange ) -> rate
}
*/



calculation FixedAmount <"2006 ISDA Definition Article 5 Section 5.1. Calculation of a Fixed Amount: The Fixed Amount payable by a party on a Payment Date will be: (a) if an amount is specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, that amount; or (b) if an amount is not specified for the Swap Transaction as the Fixed Amount payable by that party for that Payment Date or for the related Calculation Period, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Fixed Amount = Calculation Amount × Fixed Rate × Day Count Fraction.">
{
	fixedAmount = calculationAmount * fixedRate * dayCountFraction
	
	where
		calculationAmount	: InterestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
		fixedRate			: InterestRatePayout -> rateSpecification -> fixedRate -> initialValue
		dayCountFraction	: InterestRatePayout -> dayCountFraction
}

calculation FloatingAmount <"2006 ISDA Definition Article 6 Section 6.1. Calculation of a Floating Amount: Subject to the provisions of Section 6.4 (Negative Interest Rates), the Floating Amount payable by a party on a Payment Date will be: (a) if Compounding is not specified for the Swap Transaction or that party, an amount calculated on a formula basis for that Payment Date or for the related Calculation Period as follows: Floating Amount = Calculation Amount × Floating Rate + Spread × Floating Rate Day Count Fraction (b) if “Compounding” is specified to be applicable to the Swap Transaction or that party and 'Flat Compounding' is not specified, an amount equal to the sum of the Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period; or (c) if 'Flat Compounding' is specified to be applicable to the Swap Transaction or that party, an amount equal to the sum of the Basic Compounding Period Amounts for each of the Compounding Periods in the related Calculation Period plus the sum of the Additional Compounding Period Amounts for each such Compounding Period.">
{
	 // TODO - The below calculation needs to be refined for the case of negative interest rate and compounding
	 // TODO - The ISDA 2006 doesn't make reference to the FpML floatingRateMultiplierSchedule.
	 // Discussed resolution path with Jonathan & Harry is for Jonathan to ask the Rates Committee if the rate multiplier is actually used.
	 
	floatingAmount = calculationAmount * ( floatingRate + spread ) * dayCountFraction
	
	where
		calculationAmount	: InterestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
		floatingRate		: ResolveRateIndex( InterestRatePayout -> rateSpecification -> floatingRate -> floatingRateIndex ) -> rate
		// TODO: question to group: why can a float rate calculation node in FpML contain multiple rate schedules?
		spread				: GetRateSchedule( InterestRatePayout -> rateSpecification -> floatingRate ) -> schedule -> initialValue
		dayCountFraction	: InterestRatePayout -> dayCountFraction 
}

calculation DayCountFractionEnum._1_1 <"2006 ISDA Definition Article 4 section 4.16(a):	if “1/1” is specified, 1;">
{
	= 1.0
	
	where
		payout : InterestRatePayout
}

calculation DayCountFractionEnum.ACT_ACT_ISDA <"2006 ISDA Definition Article 4 section 4.16(b): if “Actual/Actual”, “Actual/Actual (ISDA)”, “Act/Act” or “Act/Act (ISDA)” is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365 (or, if any portion of that Calculation Period or Compounding Period falls in a leap year, the sum of (i) the actual number of days in that portion of the Calculation Period or Compounding Period falling in a leap year divided by 366 and (ii) the actual number of days in that portion of the Calculation Period or Compounding Period falling in a non-leap year divided by 365);">
{
	= (daysInNonLeapPeriod / 365) + (daysInLeapYearPeriod / 366)
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
		
		daysInLeapYearPeriod <"The number of days of the period that fall in a leap year.">:
			calculationPeriod -> daysInLeapYearPeriod
		
		daysInNonLeapPeriod <"The difference between the total days in the period and the days in leap year period">:
			(calculationPeriod -> daysInPeriod) - (calculationPeriod -> daysInLeapYearPeriod)	
}

calculation DayCountFractionEnum.ACT_ACT_ICMA <"2006 ISDA Definition Article 4 section 4.16(c):	(c)	if “Actual/Actual (ICMA)” or “Act/Act (ICMA)” is specified, a fraction equal to “number of days accrued/number of days in year”, as such terms are used in Rule 251 of the statutes, by-laws, rules and recommendations of the International Capital Market Association (the “ICMA Rule Book”), calculated in accordance with Rule 251 of the ICMA Rule Book as applied to non US dollar denominated straight and convertible bonds issued after December 31, 1998, as though the interest coupon on a bond were being calculated for a coupon period corresponding to the Calculation Period or Compounding Period in respect of which payment is being made;">
{
	// TODO support the long initial and final stubs	
	= daysInPeriod / (daysInPeriod * periodsInYear)
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
			
		daysInPeriod <"Number of calendar in the calculation period">:
			calculationPeriod -> daysInPeriod
		
		periodsInYear <"Number of calculation periods in a year">:
			PeriodsInYear( InterestRatePayout -> calculationPeriodDates -> calculationPeriodFrequency) -> numberOfPeriods
}

calculation DayCountFractionEnum.ACT_365_FIXED <"2006 ISDA Definition Article 4 section 4.16(d): If 'Actual/365 (Fixed)', 'Act/365 (Fixed)', 'A/365 (Fixed)' or 'A/365F' is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365.">
{
	= daysInPeriod / 365
	
	where
		daysInPeriod <"Number of calendar in the calculation period">:
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates ) -> daysInPeriod
}

calculation DayCountFractionEnum.ACT_360 <"'2006 ISDA Definition Article 4 section 4.16(e): if “Actual/360”, “Act/360” or “A/360” is specified, the actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360.">
{
	= daysInPeriod / 360
	
	where
		daysInPeriod <"Number of calendar in the calculation period">:
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates ) -> daysInPeriod
}

calculation DayCountFractionEnum._30_360 <"2006 ISDA Definition Article 4 section 4.16(f): if “30/360”, “360/360” or “Bond Basis” is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.">
{
	= (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
	
		startYear <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">: 
			calculationPeriod -> startDate -> year
		
		endYear <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> year
		
		startMonth <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">:
			calculationPeriod -> startDate -> month
		
		endMonth <"The calendar month, expressed as number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> month
		
		endDay <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31 and D2, is greater than 29, in which case D2 will be 30">:
			if calculationPeriod -> startDate -> day > 29 then Min( calculationPeriod -> endDate -> day, 30 ) else calculationPeriod -> endDate -> day
		
		startDay <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case, will be 30">:
			 Min( calculationPeriod -> startDate -> day, 30 )		
}

calculation DayCountFractionEnum._30E_360 <"2006 ISDA Definition Article 4 section 4.16(g): If '30E/360' or 'Eurobond Basis' is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows:[[360 x (Y2 - Y1)] + [30 x (M2 - M1)] + (D2 - D1)]/360.">
{
	= (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
	
		startYear <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">:
			calculationPeriod -> startDate -> year
	
		endYear <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> year
				
		startMonth <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">:
			calculationPeriod -> startDate -> month
		
		endMonth <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> month
		
		endDay <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30">:
			Min( calculationPeriod -> endDate -> day, 30 )
		
		startDay <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless such number would be 31, in which case will be 30"> :
			Min( calculationPeriod -> startDate -> day, 30 )
}

calculation DayCountFractionEnum._30E_360_ISDA <"2006 ISDA Definition Article 4 section 4.16(h): if “30E/360 (ISDA)” is specified, the number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 360, calculated on a formula basis as follows: [[360 × (Y2 - Y1)]+[30 × (M2 - M1)] +(D2 - D1)]/360 ">
{
	= (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
			
		alias interestRatePayoutTerminationDate
			ToAdjustedDate (InterestRatePayout -> calculationPeriodDates -> terminationDate)
				
		alias startDateIsInLeapYear
			IsLeapYear(calculationPeriod -> startDate -> year)
		
		alias endDateIsInLeapYear
			IsLeapYear(calculationPeriod -> endDate -> year)
	
		startYear <"The year, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">:
			calculationPeriod -> startDate -> year
		
		endYear <"The year, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> year
			
		startMonth <"The calendar month, expressed as a number, in which the first day of the Calculation Period or Compounding Period falls">:
			calculationPeriod -> startDate -> month
			
		endMonth <"The calendar month, expressed as a number, in which the day immediately following the last day included in the Calculation Period or Compounding Period falls">:
			calculationPeriod -> endDate -> month
			
		startDay <"The first calendar day, expressed as a number, of the Calculation Period or Compounding Period, unless (i) that day is the last day of February or (ii) such number would be 31, in which case will be 30">:
			if ( (startDateIsInLeapYear = False and calculationPeriod -> startDate -> month = 2 and calculationPeriod -> startDate -> day = 28)
				or (startDateIsInLeapYear = True and calculationPeriod -> startDate -> month = 2 and calculationPeriod -> startDate -> day = 29)
				or (calculationPeriod -> startDate -> day = 31)) = True 
			then 30 else calculationPeriod -> startDate -> day
			
		endDay <"The calendar day, expressed as a number, immediately following the last day included in the Calculation Period or Compounding Period, unless (i) that day is the last day of February but not the Termination Date or (ii) such number would be 31, in which case will be 30">:
			if ( (endDateIsInLeapYear = False and calculationPeriod -> endDate -> month = 2 and calculationPeriod -> endDate -> day = 28)
				or (endDateIsInLeapYear = True and calculationPeriod -> endDate -> month = 2 and calculationPeriod -> endDate -> day = 29)
				or (calculationPeriod -> endDate -> day = 31)
				or (calculationPeriod -> endDate = interestRatePayoutTerminationDate -> adjustedDate)) = True 
			then 30 else calculationPeriod -> endDate -> day
}

calculation DayCountFractionEnum.ACT_365L <"The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made divided by 365 (or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366). ">
{
	= daysInPeriod / daysInYear
	
	where
		alias calculationPeriod
			CalculationPeriod( InterestRatePayout -> calculationPeriodDates )
		
		alias endDateIsInLeapYear
			IsLeapYear(calculationPeriod -> endDate -> year)
		
		daysInPeriod <"The actual number of days in the Calculation Period or Compounding Period in respect of which payment is being made ">:
			calculationPeriod -> daysInPeriod
		
		daysInYear <"365 or, if the later Period End Date of the Calculation Period or Compounding Period falls in a leap year, divided by 366. ">: 
			if (endDateIsInLeapYear = True) then 366 else 365
}

function CalculationPeriod( calculationPeriodDates CalculationPeriodDates ) <"2006 ISDA Definition Section 4.13. 'Calculation Period' means, in respect of a Swap Transaction and a party, each period from, and including, one Period End Date of that party to, but excluding, the next following applicable Period End Date during the Term of the Swap Transaction, except that (a) the initial Calculation Period for the party will commence on, and include, the Effective Date and (b) the final Calculation Period for the party will end on, but exclude, the Termination Date.">
{
	startDate date;
	endDate date;
	daysInPeriod int;
	daysInLeapYearPeriod int;
}

function GetRateSchedule( floatingRateCalculation FloatingRateSpecification )
{
	schedule SpreadSchedule;
}

function ResolveRateIndex( index FloatingRateIndexEnum ) <"The function to specify that the floating rate index enumeration will be expressed as a number once the rate is observed.">
{
	rate number;
}

function ToAdjustedDate( terminationDate AdjustableOrRelativeDate )
{
	adjustedDate date;
}

function PeriodsInYear( frequency CalculationPeriodFrequency )
{
	numberOfPeriods int;
}