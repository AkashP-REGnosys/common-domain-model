namespace "org.isda.cdm"

class AllocationOutcome <"A class to specify the allocated outcome as the combination of an execution which state is specified as 'Allocated' and a contract or set of contract(s). (The allocation to one single contract is deemed appropriate.)">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
	contract Contract (1..*);
		[synonym Rosetta_Workbench value trade]
}

data rule AllocationOutcome_execution <"The allocation outcome must result in execution state of 'Allocated'.">
	when AllocationOutcome exists
	then AllocationOutcome -> execution -> closedState -> state = ClosedStateEnum.Allocated

class AllocationPrimitive <"The primitive event to represent a split/allocation of a contractual product or a contract.">
{
	before ExecutionState (1..1);
		[synonym Rosetta_Workbench value before]
	after AllocationOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class CashTransferBreakdown extends TransferBreakdown
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount of the payment.">;
		[synonym Rosetta_Workbench value amount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType]
}

class CashTransferComponent extends TransferBase
{
	payerReceiver PayerReceiver (1..1) <"The payer and receiver party information.">;
	amount Money (1..1) <"The currency amount.">;
		[synonym Rosetta_Workbench value amount]
		[synonym DTCC_11_0, DTCC_9_0 value paymentAmount]
	cashflowType CashflowTypeEnum (0..1) <"The qualification of the type of cashflow, when not inferred from a derived through lineage e.g. brokerage fee, premium, upfront fee etc.">;
		[synonym Rosetta_Workbench value cashflowType]
		[synonym DTCC_11_0, DTCC_9_0 value cashflowType path "calculationDetails.grossCashflow" meta cashflowTypeScheme]
	breakdown CashTransferBreakdown (0..*) <"The cash transfer breakdown, when the transfer corresponds to a net amount across several components which breakdown is deemed relevant (e.g. the net cash transfer related to several contracts, or to the net proceeds across several payout components).">;
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0 value breakdown]
}

/*
 * TODO - The commodity transfer component and its associated breakdown should be deemed as sample implementations,
 * which need to be confirmed through relevant user stories and use cases
 */
class CommodityTransferBreakdown extends TransferBreakdown
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
}

class CommodityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	commodity Commodity (1..1);
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	unit UnitEnum (1..1) <"The unit of measure, applicable to physical assets.">;
	timeUnit TimeUnitEnum (0..1);
	assetTransferType AssetTransferTypeEnum (0..1) <"The type of transfer, e.g. Free of Payment.">;
	breakdown CommodityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class ComputedAmount <"A class to specify the outcome of a computed amount, for testing purposes.">
{
	callFunction calculation (1..1);
	amount number (1..1);
	currency string (0..1) scheme;
		[synonym Rosetta_Workbench value currency meta currencyScheme]
}

class ContractState <"A class to specify a contract instantiation with respect to the before and/or after state of lifecycle events.">
{
	contract Contract (1..1);
        [synonym Rosetta_Workbench value trade]
        [synonym DTCC_11_0, DTCC_9_0 value FpML path "Trade"]
        [synonym DTCC_11_0, DTCC_9_0 value TradeMsg path "Manifest"]
        [synonym DTCC_11_0, DTCC_9_0 value ReportingJurisdiction path "ReportingData.ReportingHeader"]
        [synonym CME_SubmissionIRS_1_0 value FpML path "Instrmt.SecXML"]
}

class CreditLimit
	[synonym FpML_5_10 value CreditLimit]
{
	limitId string (0..1) scheme;
		[synonym FpML_5_10 value limitId meta creditLimitIdScheme]
	applicableProduct ProductIdentification (0..1) <"Further to the FpML standard, the CDM ProductIdentification provides the ability to associate a CDM qualified product.">;
	currency string (0..1) scheme;
		[synonym FpML_5_10 value currency meta currencyScheme]
	tenor Period (0..1) <"The maximum allowed tenor for a trade under this limit. When this structure is used as part of a suspendCredit message, this tenor imposes a temporary tenor limit on allowed trade types.">;
		[synonym FpML_5_10 value tenor]
	limitApplicable LimitApplicable (0..*);
		[synonym FpML_5_10 value limitApplicable]
	expirationDateTime BusinessCenterTime (0..1) <"The CDM naming include the time suffix because the FpML element is actually of type dateTime. Also, the attribute is of type BusinessCenterTime because of the design decision to only have time that are specified by reference to a timezone, with that class being deemed the proper implementation.">;
		[synonym FpML_5_10 value expirationDate]
}

class CreditLimitInformation <"A class to represent the credit limit utilization information.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
{
	limitApplicable LimitApplicableExtended (1..*);
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitApplicable]
}

class CreditLimitUtilisation <"Credit limit utilisation breakdown by executed trades and pending orders.">
	[synonym FpML_5_10 value CreditLimitUtilization]
{
	executed CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to executed trades.">;
		[synonym FpML_5_10 value executed]
	pending CreditLimitUtilisationPosition (0..1) <"Credit limit utilisation attributable to pending unexecuted orders.">;
		[synonym FpML_5_10 value pending]
}

class CreditLimitUtilisationPosition
	[synonym FpML_5_10 value CreditLimitUtilizationPosition]
{
	shortPosition number (0..1) <"Credit limit utilisation attributable to short positions.">;
		[synonym FpML_5_10 value short]
	longPosition number (0..1) <"Credit limit utilisation attributable to long positions.">;
		[synonym FpML_5_10 value long]
	global number (0..1) <"Global credit limit utilisation amount, agnostic of long/short position direction.">;
		[synonym FpML_5_10 value global]
}

class Curve one of
{
	interestRateCurve InterestRateCurve (0..1);
		[synonym Rosetta_Workbench value interestRateCurve]
	commodityCurve CommodityReferencePriceEnum (0..1) scheme; // This is just an illustrative alternative curve instance, which implementation needs to be refined and confirmed
		[synonym Rosetta_Workbench value commodityCurve meta commodityReferencePriceScheme]
}

class CustomisedWorkflow <"In its initial iteration, this class is meant to support the DTCC TIW workflow information.">
{
	itemName string (1..1) <"In this initial iteration, this corresponds to the DTCC TIW element name.">;
		[synonym DTCC_11_0, DTCC_9_0 set to "comment" when path = "PartyWorkflowFields.comment"]
		[synonym DTCC_11_0, DTCC_9_0 set to "superId" when path = "PartyWorkflowFields.superId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "deskId" when path = "PartyWorkflowFields.deskId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "eTradeId" when path = "PartyWorkflowFields.eTradeId"]
		[synonym DTCC_11_0, DTCC_9_0 set to "designatedParty" when path = "PartyWorkflowFields.designatedParty"]
		[synonym DTCC_11_0, DTCC_9_0 set to "brokerName" when path = "PartyWorkflowFields.brokerName"]
		[synonym DTCC_11_0, DTCC_9_0 set to "branchLocation" when path = "PartyWorkflowFields.branchLocation"]
		[synonym DTCC_11_0, DTCC_9_0 set to "midMarketPriceType" when path = "PartyWorkflowFields.midMarketPrice.midMarketPriceType"]
		[synonym DTCC_11_0, DTCC_9_0 set to "amount" when path = "PartyWorkflowFields.midMarketPrice.amount"]
		[synonym CME_SubmissionIRS_1_0 set to "ClientOrderId" when path = "ClOrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "TradeOriginationSystem" when path = "InptSrc"]
		[synonym CME_SubmissionIRS_1_0 set to "OriginatingTradeId" when path = "OrigTrdID"]
		[synonym CME_SubmissionIRS_1_0 set to "ExecutionTime" when path = "TrdRegTS.TS" and "TrdRegTS.Typ" = "1"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyType" when path = "Pty.R"]
		[synonym CME_SubmissionIRS_1_0 set to "PartyIdentifier" when path = "Pty.Src"]
	itemValue string (1..1) <"In this initial iteration, this corresponds to the DTCC value.">;
		[synonym DTCC_11_0, DTCC_9_0 value comment path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value superId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value deskId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value eTradeId path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value designatedParty path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value brokerName path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value branchLocation path "PartyWorkflowFields"]
		[synonym DTCC_11_0, DTCC_9_0 value midMarketPriceType path "PartyWorkflowFields.midMarketPrice"]
		[synonym DTCC_11_0, DTCC_9_0 value amount path "PartyWorkflowFields.midMarketPrice"]
		[synonym CME_SubmissionIRS_1_0 value ClOrdID]
		[synonym CME_SubmissionIRS_1_0 value InptSrc]
		[synonym CME_SubmissionIRS_1_0 value OrigTrdID]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdRegTS"]
		[synonym CME_SubmissionIRS_1_0 set to "Customer Account" when "Pty.R" = "24"]
		[synonym CME_SubmissionIRS_1_0 set to "Custom" when "Pty.Src" = "D"]
}

class Event rosettaKey
{
	id (0..1);
		[synonym Rosetta_Workbench meta id]
	messageInformation MessageInformation (0..1);
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Trade"]
		[synonym DTCC_11_0, DTCC_9_0 value FpML path "Body.OTC_Matching.Payment"]
		[synonym DTCC_11_0, DTCC_9_0 value RouteInfo path "Header.OTC_RM.Delivery"]
		[synonym DTCC_11_0, DTCC_9_0 value Manifest path "Header.OTC_RM"]
		[synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
	timestamp EventTimestamp (1..*) <"The set of timestamp(s) associated with the event as a collection of [dateTime, qualifier].">;
		[synonym Rosetta_Workbench value timestamp]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Trade.FpML"]
		[synonym DTCC_11_0, DTCC_9_0 value Route path "Header.OTC_RM.Delivery.RouteHist"]
		[synonym DTCC_11_0, DTCC_9_0 value header path "Body.OTC_Matching.Payment.FpML"]
        [synonym CME_ClearedConfirm_1_17 value timestamps path "clearingConfirmed.trade.tradeHeader"]
        [synonym CME_ClearedConfirm_1_17 value header path "clearingConfirmed"]
    eventIdentifier Identifier (1..*) <"The event identifier, which has 3 components: an actual identifier, an issuer and a version number. One and only one identifier can be associated with a lifecycle event.">;
		[synonym Rosetta_Workbench value eventIdentifier]
		[synonym DTCC_11_0, DTCC_9_0 value Submitter path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value ContraTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value YourTradeId path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym DTCC_11_0, DTCC_9_0 value tradeIdentifyingItems path "Header.OTC_RM.Manifest.TradeMsg"]
	eventQualifier eventType (0..1) <"The CDM event qualifier, which corresponds to the outcome of the isEvent qualification logic. This value is derived by the CDM from the event features.">;
	eventDate date (1..1);
		[synonym Rosetta_Workbench value eventDate]
	effectiveDate date (0..1);
		[synonym Rosetta_Workbench value effectiveDate]
	action ActionEnum (1..1) <"Specifies whether the event is a new, a correction or a cancellation.">;
		[synonym Rosetta_Workbench
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True,
			set to ActionEnum.Cancel when "isRetraction" = True]
		[synonym FpML_5_10
			set to ActionEnum.New when "isCorrection" = False,
			set to ActionEnum.Correct when "isCorrection" = True]
		[synonym DTCC_11_0, DTCC_9_0 value Activity path "Header.OTC_RM.Manifest.TradeMsg"]
		[synonym CME_SubmissionIRS_1_0 value TransTyp path "TrdCaptRpt"]
	intent IntentEnum (0..1);
		[synonym Rosetta_Workbench value intent]
	party Party (0..*) <"The specification of the event parties. This attribute is optional, as not applicable to certain events (e.g. most of the observations).">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, CME_ClearedConfirm_1_17 value party]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Trade.FpML" ]
		[synonym DTCC_11_0, DTCC_9_0 value party path "Body.OTC_Matching.Payment.FpML" ]
	account Account (0..*) <"Optional account information that could be associated to the event.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0 value account]
		[synonym CME_ClearedConfirm_1_17 value account path "clearingConfirmed"]
	lineage Lineage (0..1);
		[synonym Rosetta_Workbench value lineage]
	primitive PrimitiveEvent (1..1);
		[synonym Rosetta_Workbench value primitive]
	functionCall string (0..1) <"This is placeholder concept for a function call into a calculation that will return an outcome. This concept needs to be further firmed out.">;
		[synonym Rosetta_Workbench value functionCall]
	eventEffect EventEffect (0..1) <"The set of effects associated with the lifecycle event, i.e. generated cashflows, contracts (from, say, novation events), listed products (from, say, a bond option exercise event)  values and more. Those are represented through a set of rosettaKey references. This attribute is optional in order to provide implementers with the ability not to make use of this feature.">;
}

class EventEffect <"The set of operational and positional effects associated with a lifecycle event, alongside the reference to the contract reference(s) that is subject to the event (and is positioned in the before state of the event primitive).">
{
	effectedContract Contract (0..*) rosettaKey <"A pointer to the contract(s) to which the event effect(s) apply, i.e. in the before event state.">;
	contract Contract (0..*) rosettaKey <"A pointer to the contract effect(s), an example of such being the outcome of a new trade, swaption exercise or novation event.">;
    productIdentifier ProductIdentifier (0..*) rosettaKey <"A pointer to the product identifier effect(s), an example of such being the outcome of the physical exercise of a bond option.">;
	transfer Transfer (0..*) rosettaKey <"A pointer to the transfer effect(s), either a cash, security or other asset.">;
}

class EventTestBundle <"A class which combines several events for testing purposes.">
{
	event Event (2..*);
		[synonym Rosetta_Workbench value event]
	computedAmount ComputedAmount (0..*);
		[synonym Rosetta_Workbench value computedAmount]
}

class EventTimestamp <"A class to represent the various set of timestamps that can be associated with lifecycle events, as a collection of [dateTime, qualifier]">
{
	dateTime zonedDateTime (1..1) <"The CDM specifies that the zoned date time is to be expressed in accordance with ISO 8601, either as UTC as an offset to UTC.">;
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value creationTimestamp]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value expiryTimestamp]
		[synonym DTCC_11_0, DTCC_9_0 value ReceiveTime]
		[synonym CME_ClearedConfirm_1_17 value submittedForClearing]
		[synonym CME_SubmissionIRS_1_0 value TxnTm path "TrdCaptRpt"]
		[synonym CME_SubmissionIRS_1_0 value Snt path "TrdCaptRpt.Hdr"]
		[synonym CME_SubmissionIRS_1_0 value TS path "TrdCaptRpt.TrdRegTS"]
	qualification EventTimeStampQualificationEnum (1..1);
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimeStampQualificationEnum.eventCreationTime when "creationTimestamp" exists]
		[synonym Rosetta_Workbench, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 set to EventTimeStampQualificationEnum.eventExpirationTime when "expiryTimestamp" exists]
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench set to EventTimeStampQualificationEnum.clearingSubmissionTime when "submittedForClearing" exists]
		[synonym DTCC_11_0, DTCC_9_0 set to EventTimeStampQualificationEnum.eventSubmittedTime when "ReceiveTime" exists]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.transactionCreationTime when path = "TrdCaptRpt.TxnTm"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.eventSentTime when path= "TrdCaptRpt.Hdr.Snt"]
		[synonym CME_SubmissionIRS_1_0 set to EventTimeStampQualificationEnum.executionTime when path= "TrdCaptRpt.TrdRegTS.TS" and "TrdCaptRpt.TrdRegTS.Typ" = 1]
}

class Execution rosettaKey
{
	identifier Identifier (1..*) <"The identifier(s) associated with the execution.">;
		[synonym Rosetta_Workbench value identifier]
		[synonym DTCC_11_0, DTCC_9_0 value partyTradeIdentifier path "Submitter"]
	tradeDate date (1..1) id <"The trade/execution date.">;
		[synonym Rosetta_Workbench value tradeDate meta id]
	contractualProduct ContractualProduct (1..1);
		[synonym Rosetta_Workbench value contractualProduct]
	party Party (0..*) <"The party reference is optional because positioned as part of the Event class when the execution is specified as part of such context.">;
	closedState ClosedState (0..1) <"The qualification what led to the execution closure alongside with the dates on which this closure takes effect.">;
		[synonym Rosetta_Workbench value closedState]
}

class ClearingWorkflow <"A class to specify the clearing workflow information: clearing status, clearing venue and (when applicable) execution venue identification, party-specific execution workflow information, ...">
{
	clearingStatus WorkflowEnum (1..1);
		[synonym CME_SubmissionIRS_1_0 value RptTyp]
		[synonym Rosetta_Workbench value clearingStatus]
		[synonym CME_ClearedConfirm_1_17 value status path "trade.tradeHeader"]
	clearingVenue string (0..1) <"The clearing venue identification.">;
	 	[synonym CME_SubmissionIRS_1_0 value TSub path "Hdr"]
	originatingEvent OriginatingEventEnum (0..1) <"The qualification by the clearing facility of whether the cleared trade results from a trade presented for clearing by market participants (in which case it is qualified as a 'New Trade') or whether it results from a process that is internal to the CCP, in which case this process will be qualified accordingly (e.g. Transfer, Novation, Compression, ...).">;
		[synonym CME_ClearedConfirm_1_17 value originatingEvent path "trade.tradeHeader"]
		[synonym Rosetta_Workbench value originatingEvent]
	executionVenue string (0..1) <"The execution venue identification, when applicable.">;
	 	[synonym CME_SubmissionIRS_1_0 value SID path "Hdr"]
	executionType ExecutionTypeEnum (0..1) <"Specifies how the trade was executed, e.g. via voice or electronically.">;
		[synonym CME_SubmissionIRS_1_0 value VenuTyp]
	partyExecutionWorkflow PartyCustomisedWorkflow (0..*) <"Information related to the execution workflow for each of the parties to the contract. This is relevant for the clearing event.">;
		[synonym CME_SubmissionIRS_1_0 value RptSide]
}

class ExerciseOutcome <"The exercise outcome combines the option contract (which states would be 'Exercised' in case of a full exercise and which would have a reduced notional in case of partial exercise) and either a physical or partial exercise.">
{
	contract Contract (1..1);
		[synonym Rosetta_Workbench value contract]
	physicalExercise PhysicalExercise (0..1);
		[synonym Rosetta_Workbench value physicalExercise]
	cashExercise Cashflow (0..1);
		[synonym Rosetta_Workbench value cashExercise]
}

choice rule ExerciseOutcome_choice <"A option exercise results in either a physical or a cash exercise.">
	for ExerciseOutcome required choice between
	physicalExercise and cashExercise

class ExecutionState <"A class to specify an execution instantiation with respect to the before and/or after state of lifecycle events.">
{
	execution Execution (1..1);
		[synonym Rosetta_Workbench value execution]
}

class ExercisePrimitive <"This primitive leverages the FpML OptionExercise construct, except for the exerciseTiming which is deemed as associated to a request for exercise that is meant to take place, as opposed to the actual exercise event.">
{
	exerciseDate AdjustableOrAdjustedDate (0..1);
		[synonym Rosetta_Workbench value exerciseDate]
	exerciseTime BusinessCenterTime (0..1);
		[synonym Rosetta_Workbench value exerciseTime]
	fullExercise boolean (1..1);
		[synonym Rosetta_Workbench value fullExercise]
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ExerciseOutcome (1..1);
		[synonym Rosetta_Workbench value after]
}

class Inception <"The primitive event for the inception of a new contract between parties. It is expected that this primitive will be adjusted or deprecated once the CDM scope is extended to the pre-execution space.">
{
	before ContractState (0..0) <"The (0..0) cardinality reflects the fact that there is no contract in the before state of an inception primitive. As noted in the definition associated with the class, this is expected to change once the CDM scope is extended to the pre-execution space.">;
		[synonym Rosetta_Workbench value before]
	after PostInceptionState (1..1) <"The after state corresponds to the new contract between the parties.">;
		[synonym Rosetta_Workbench value after]
		[synonym DTCC_11_0 value OTC_RM path "Header"]
		[synonym DTCC_11_0, DTCC_9_0 value OTC_Matching path "Body" set when "Header.OTC_RM.Manifest.TradeMsg.TransType" = "Trade"]
		[synonym CME_ClearedConfirm_1_17 value clearingConfirmed]
		[synonym CME_SubmissionIRS_1_0 value TrdCaptRpt]
}

class InterestRateCurve
{
	floatingRateIndex FloatingRateIndexEnum (1..1) scheme;
		[synonym Rosetta_Workbench value floatingRateIndex meta floatingRateIndexScheme]
	tenor Period (1..1);
		[synonym Rosetta_Workbench value tenor]
}

class LimitApplicable
	[synonym FpML_5_10 value LimitApplicable]
{
	limitType CreditLimitTypeEnum (0..1) scheme <"Standard code to indicate which type of credit line is being referred to - i.e. IM, DV01, PV01, CS01, Notional, Clip Size, Notional, maximumOrderQuantity.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value limitType meta creditLimitTypeScheme]
	clipSize int (0..1) <"This element is required in FpML, optional in CDM for the purpose of accommodating the CME data representation while making reference to the FpML one.">;
		[synonym FpML_5_10 value clipSize]
	amountUtilized number (0..1) <"The limit utilised by all the cleared trades for the limit level and limit type. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountUtilized]
	utilization CreditLimitUtilisation (0..1);
		[synonym FpML_5_10 value utilization]
	amountRemaining number (0..1) <"The limit remaining for the limit level and limit type. This does not take into account any pending trades. While the attribute is of type integer in FpML and the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value amountRemaining]
	currency string (0..1) scheme;
		[synonym FpML_5_10, CME_ClearedConfirm_1_17, Rosetta_Workbench value currency meta currencyScheme]
	velocity Velocity (0..1);
		[synonym FpML_5_10 value velocity]
}

choice rule LimitApplicable_choice <"Choice rule to represent an FpML choice construct.">
 	for LimitApplicable optional choice between
	amountUtilized and utilization

class LimitApplicableExtended extends LimitApplicable <"A class to represent the CDM attributes that are not part of the FpML standard. Once broader usage is confirmed, it is expected that those two classes can be collapsed.">
	[synonym CME_ClearedConfirm_1_17 value CreditLimitInformation]
{
	// TODO - We need to get a better understanding of what the level is.
	level string (0..1) scheme;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value level meta creditLimitLevelScheme]
	limitAmount number (0..1) <"The total limit available for the limit level and limit type. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitAmount]
	limitImpactDueToTrade number (0..1) <"The limit utilised by this specific trade. While the attribute is of type integer in the CME schema, it has been specified to be of type number in the CDM to take into consideration java size limits as well as for consistency purposes with the way most monetary amounts are expressed.">;
		[synonym CME_ClearedConfirm_1_17, Rosetta_Workbench value limitImpactDueToTrade]
}

class Lineage <"The class to provide lineage information across transactions.">
{
	lineageQualifier LineageQualifierEnum (0..1) <"The lineage qualification, which is meant to provide insight into the object that is represented by the rosettaKey reference. The purpose of this qualifier can be illustrated by a novated trade and a cleared trade, which look very similar in the sense that they are both model through an inception primitive, with a lineage into, respectively, the novated trade and the alpha trade. Qualifiying the lineage as NovatedTrade and AlphaTrade hence provides further insight into those event components.">;
	contractReference Contract (0..*) rosettaKey reference;
	    [synonym Rosetta_Workbench value contractReference meta href]
	eventReference Event (0..*) rosettaKey reference; 
		[synonym Rosetta_Workbench value eventReference meta href]
	cashflowReference Transfer (0..*) rosettaKey reference;
		[synonym Rosetta_Workbench value cashflowReference meta href] 
	creditDefaultPayoutReference CreditDefaultPayout (0..*) rosettaKey reference;
		[synonym Rosetta_Workbench value creditDefaultReference meta href]
	interestRatePayoutReference InterestRatePayout (0..*) rosettaKey reference;
		[synonym Rosetta_Workbench value interestRatePayoutReference meta href]
	optionPayoutReference OptionPayout (0..*) rosettaKey reference;
		[synonym Rosetta_Workbench value optionPayoutReference meta href]
}

class MessageInformation <"This class corresponds to the components of the FpML MessageHeader.model.">
{
	messageId string (1..1) scheme <"A unique identifier assigned to the message.">;
		[synonym Rosetta_Workbench value messageId path "messageInformation" meta messageIdScheme]
		[synonym DTCC_11_0, DTCC_9_0 value messageId path "header" meta messageIdScheme]
		[synonym CME_ClearedConfirm_1_17 value messageId meta messageIdScheme]
	sentBy string (0..1) scheme <"The identifier for the originator of a message instance.">;
		[synonym Rosetta_Workbench value sentBy path "messageInformation" meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value From]
		[synonym CME_ClearedConfirm_1_17 value sentBy meta messageAddressScheme]
		[synonym CME_SubmissionIRS_1_0 value SSub path "TrdCaptRpt.Hdr"]
	sentTo string (0..*) scheme <"The identifier(s) for the recipient(s) of a message instance.">;
		[synonym Rosetta_Workbench value sentTo path "messageInformation" meta messageAddressScheme]
		[synonym CME_ClearedConfirm_1_17 value sendTo meta messageAddressScheme]
		[synonym DTCC_11_0, DTCC_9_0 value To]
		[synonym CME_SubmissionIRS_1_0 value TID path "TrdCaptRpt.Hdr"]
	copyTo string (0..*) scheme  <"A unique identifier (within the specified coding scheme) giving the details of some party to whom a copy of this message will be sent for reference.">;
}

class ObservationPrimitive <"The primitive event to represent an observation.">
{
	source ObservationSource (1..1) <"The observation source.">;
		[synonym Rosetta_Workbench value source]
	observation number (1..1) <"The observation value.">;
		[synonym Rosetta_Workbench value observation]
	date date (1..1) <"The observation date.">;
		[synonym Rosetta_Workbench value date]
		[synonym DTCC_11_0, DTCC_9_0 value observationDate]
	time TimeZone (0..1) <"The observation time, with a possible indication of the timezone dimension.">;
		[synonym Rosetta_Workbench value time]
	side QuotationSideEnum (0..1) <"The side (bid/mid/ask) of the observation, when applicable.">;
		[synonym Rosetta_Workbench value side]
}

class ObservationSource <"The observation source can be composed of an curve and/or and information source.">
{
	curve Curve (0..1);
		[synonym Rosetta_Workbench value curve]
	informationSource InformationSource (0..1);
		[synonym Rosetta_Workbench value informationSource]
}

data rule ObservationSource_content <"ObservationSource should not be empty, although the attribute cardinality would allow that.">
	when ObservationSource exists
	then ( ObservationSource -> curve and ObservationSource -> informationSource ) exists
		or ObservationSource -> curve exists
		or ObservationSource -> informationSource exists

class PartyCustomisedWorkflow <"A class to specify a party-related, non-standardised data in a generic form.">
{
	partyReference Party (0..1) reference <"Reference to the party to which the workflow pertains to.">;
		[synonym DTCC_11_0, DTCC_9_0 value partyReference meta href]
	partyName string (0..1) <"The party name to which the workflow pertains to.">;
		[synonym CME_SubmissionIRS_1_0 value ID path "Pty"]
	customisedWorkflow CustomisedWorkflow (1..*) <"Non-standardised data in a generic form.">;
}

choice rule PartyCustomisedWorkflow_choice <"The identification of the party to which the PartyCustomisedWorkflow pertains to can be done through either a party reference or the party name.">
	for PartyCustomisedWorkflow required choice between
	partyName and partyReference

class PhysicalExercise <"The physical exercise results into a financial product which is represented through the Product class, with an associated quantity and cashflow (e.g. a physical exercise of a bond option will result into a bond with a cash proceed which will be a function of the option strike price).">
{
	product Product (1..1);
		[synonym Rosetta_Workbench value product]
	quantity Quantity (0..1) <"The quantity associated the asset that is physically settled. This quantity should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">;
		[synonym Rosetta_Workbench value quantity]
	cashflow Cashflow (0..1) <"The cashflow component of the physical exercise.">;
		[synonym Rosetta_Workbench value cashflow]
}

data rule PhysicalExercise_quantity <"The quantity attribute should only be associated with non-contractual products, as it is then expressed as part of the contractual terms.">
	when ( PhysicalExercise -> product -> contractualProduct or PhysicalExercise -> product -> contract) exists
	then PhysicalExercise -> quantity is absent

class PostInceptionState extends ContractState
{
	creditLimitInformation CreditLimitInformation (0..1) <"Credit limit utilization information.">;
		[synonym CME_ClearedConfirm_1_17 value creditLimitInformation path "trade.tradeHeader"]
		[synonym Rosetta_Workbench value creditLimitInformation]
	clearingWorkflow ClearingWorkflow (0..1) <"Information related to clearing workflow: clearing venue, type of execution, name of execution venue when applicable, party-specific execution workflow, ...">;
	tradeWarehouseWorkflow TradeWarehouseWorkflow (0..1) <"Information related to trade warehouse workflow.">;
}

class PrimitiveEvent <"The set of primitive events.">
{
	inception Inception (0..*);
		[synonym Rosetta_Workbench value inception]
	quantityChange QuantityChangePrimitive (0..*);
		[synonym Rosetta_Workbench value quantityChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	allocation AllocationPrimitive (0..*);
		[synonym Rosetta_Workbench value allocation]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	termsChange TermsChangePrimitive (0..1);
		[synonym Rosetta_Workbench value otherTermsChange]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	exercise ExercisePrimitive (0..1);
		[synonym Rosetta_Workbench value exercise]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	observation ObservationPrimitive (0..*);
		[synonym Rosetta_Workbench value observation]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	reset ResetPrimitive (0..*);
		[synonym Rosetta_Workbench value reset]
		[synonym DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
	transfer Transfer (0..*);
		[synonym Rosetta_Workbench value transfer]
		[synonym CME_ClearedConfirm_1_17, CME_SubmissionIRS_1_0 value ignore]
		[synonym DTCC_11_0, DTCC_9_0 value Payment path "Body.OTC_Matching"]
}

class QuantityChangePrimitive <"The primitive event to represent a change in quantity or notional.">
{
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
	change ContractualQuantity (1..*);
		[synonym Rosetta_Workbench value change]
}

/*
 * TODO - Consider extending the data rule syntax to support the below data rule https://trello.com/c/1ZRsJbzN
 */
//data rule QuantityChangePrimitive_change <"The change value should be equal to the difference between the respective quantities.">_
//	when Event -> primitive -> quantityChange exists
//	then Event -> primitive -> quantityChange -> change = (quantityAfterQuantityChange - quantityBeforeQuantityChange)


class ResetPrimitive <"The primitive event to represent a reset.">
{
	date date (1..1) <"The reset date">;
		[synonym Rosetta_Workbench value date]
	resetValue number (1..1) <"The reset value">;
		[synonym Rosetta_Workbench value resetValue]
	/*
	 * Question to the CDM Group - Should the reset primitive have an associated cashflow, or just have the rate reset value?
	 * The latter seems more appropriate, but needs to be confirmed by current operational workflows.
	 * If it has the cashflow, it should also have the associated calculation.
	 */
	cashflow Cashflow (0..1) <"The cashflow resulting from the reset event.">; // The cardinality has been relaxed until the above question is settled
		[synonym Rosetta_Workbench value cashflow]
}

class SecurityTransferBreakdown
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..*) <"The security(ies) that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
}

class SecurityTransferComponent extends TransferBase
{
	transferorTransferee TransferorTransferee (1..1) <"The transferee and transferor party information.">;
	security Security (1..1) <"The security that is being transfered">;
		[synonym Rosetta_Workbench value security]
	quantity number (1..1);
		[synonym Rosetta_Workbench value quantity]
	assetTransferType AssetTransferTypeEnum (0..1); // The relevance of this attribute and the associated values need to be confirmed"
		[synonym Rosetta_Workbench value assetTransferType]
	breakdown SecurityTransferBreakdown (0..*) <"The security transfer breakdown, when the transfer corresponds to a net transfer across several components which breakdown is deemed relevant (e.g. the net security transfer related to several contracts).">;
		[synonym Rosetta_Workbench value breakdown]
}

class TermsChangePrimitive <"The primitive event to represent change(s) to the contractual terms.">
{
	before ContractState (1..1);
		[synonym Rosetta_Workbench value before]
	after ContractState (1..1);
		[synonym Rosetta_Workbench value after]
}

class TimeZone <"The time alongside with the timezone location information. This class makes use of the FpML TimezoneLocation construct.">
{
	time time (1..1) <"The observation time.">;
		[synonym Rosetta_Workbench value time]
	location string (0..1) scheme <"FpML specifies the timezoneLocationScheme by reference to the Time Zone Database (a.k.a. tz database) maintained by IANA, the Internet Assigned Numbers Authority.">;
		[synonym Rosetta_Workbench value location meta timezoneLocationScheme]
}

class TradeWarehouseWorkflow <"A class to specify trade warehouse workflow information: the identity of the trade warehouse, the contract status at the warehouse and party-specific workflow information.">
{
	warehouseIdentity WarehouseIdentityEnum (1..1);
		[synonym DTCC_11_0, DTCC_9_0 value WarehousePositionType path "WarehouseState"]
	warehouseStatus WorkflowEnum (1..1);
		[synonym DTCC_11_0, DTCC_9_0 value WarehouseStatus path "WarehouseState"]
	partyCustomisedWorkflow PartyCustomisedWorkflow (0..*) <"Non-standardised workflow data related to a party.">;
		[synonym DTCC_11_0, DTCC_9_0 value WorkflowData]
		[synonym CME_SubmissionIRS_1_0 value ignore]
}

class Transfer rosettaKey <"A class to specify the transfer primitive by providing the ability to combine a set of transfer components which are specialised by asset class.">
{
	identifier string (0..1) scheme <"The identifier which might be associated with the transfer.">;
		[synonym DTCC_11_0, DTCC_9_0 value tradeCashflowsId path "FpML" meta tradeCashflowsIdScheme]
	settlementType TransferSettlementEnum (0..1) <"The qualification as to how the transfer will settle, e.g. a DvP settlement.">;
		[synonym Rosetta_Workbench value transferType]
		[synonym DTCC_11_0, DTCC_9_0 value SettlementType path "PaymentDetails"]
	settlementDate AdjustableOrAdjustedOrRelativeDate (1..1);
		[synonym Rosetta_Workbench value settlementDate]
	cashTransfer CashTransferComponent (0..*) <"The cash transfer component of the transfer. In the case where several currencies are involved in the transfer, several components should be used, as the component supports one single currency amount.">;
		[synonym Rosetta_Workbench value cashTransfer]
		[synonym DTCC_11_0, DTCC_9_0 value payment path "FpML"]
	securityTransfer SecurityTransferComponent (0..*) <"The security transfer component of the transfer. In the case where several securities are involved in the transfer, several components should be used, as the component supports one single security.">;
		[synonym Rosetta_Workbench value securityTransfer]
	commodityTransfer CommodityTransferComponent (0..*);
	status TransferStatusEnum (0..1) <"The transfer status, e.g. Instructed, Settled...">;
		[synonym Rosetta_Workbench value status]
	settlementReference string (0..1) <"The settlement reference, when applicable.">;
		[synonym Rosetta_Workbench value settlementReference]
}

class TransferBase
{
	identifier string (0..1) scheme <"The identifier that can be associated with each of the transfer components">;
		[synonym DTCC_11_0, DTCC_9_0 value identifier meta paymentIdScheme]
	transferCalculation TransferCalculation (0..1) <"The calculation details underlying the transfer amount, when applicable.">;
		[synonym DTCC_11_0, DTCC_9_0 value calculationDetails]
}

class TransferCalculation
{
	period CalculationPeriodBase (0..1 ) <"The period adjusted start and end dates.">;
		[synonym DTCC_11_0, DTCC_9_0 value calculationPeriod path "calculationElements"]
	lineage Lineage (0..1) <"The lineage into the components used for the calculation.">;
	calculationOutcome calculation (0..1) <"The calculation outcome.">;
		[synonym Rosetta_Workbench value transferCalculation]
}

class TransferBreakdown extends TransferBase
{
	lineage Lineage (0..1) <"The lineage into the transfer components that might be associated with each of the transfer components.">;
		[synonym Rosetta_Workbench value lineage]
}

class TransferorTransferee <"A class mimicking the PayerReceiver, which is itself derived from the FpML PayerReceiver.model, to represent the transferee and transferor party information in relation to the transfer of security or commodities.">
{
	transferorPartyReference Party (1..1) reference <"A reference to the party responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerPartyReference meta href]
	transferorAccountReference Account (0..1) reference <"A reference to the account responsible for making the payments defined by this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value payerAccountReference meta href]
	transfereePartyReference Party (1..1) reference <"A reference to the party that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverPartyReference meta href]
	transfereeAccountReference Account (0..1) reference <"A reference to the account that receives the payments corresponding to this structure.">;
		[synonym FpML_5_10, CME_SubmissionIRS_1_0, DTCC_11_0, DTCC_9_0, CME_ClearedConfirm_1_17 value receiverAccountReference meta href]
}

class Velocity
	[synonym FpML_5_10 value Velocity]
{
	periodMultiplier int (0..1);
	period PeriodTimeEnum (0..1);
}

/*********************
 * Event Qualification
 */

isEvent Allocation <"The qualification of allocation event from the fact that (i) the intent is Allocation when specified, (ii) the only primitive is the allocation, (iii) the sum of quantities/notional before = after, and (iv) there is a single contractualProduct before (ensured through cardinality). Note: it is accepted that an allocation can result in a single contract.">
	Event -> intent when present = IntentEnum.Allocation
	and Event -> primitive -> allocation only exists
	/*
	 * TODO - The below syntax needs to be expanded to specify a summation
	 * This could be specify as  quantityBeforeAllocation = sum(quantityAfterAllocation)
	 */
//	and quantityBeforeAllocation = quantityAfterAllocation

alias quantityBeforeAllocation <"The alias to represent the quantity or notional amount associated to a pre-allocation contractual product in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> before -> execution -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

alias quantityAfterAllocation <"The alias to represent the quantity or notional amount associated to allocated contract(s) in terms of number of units (i.e. ignoring the currency or units denomination).">
	Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional -> initialValue
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount -> amount
	or Event -> primitive -> allocation -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount -> amount

/*
 * Temporary event qualification until such time that we firm out the proper qualification and the way to infer it
 */
isEvent CashflowCalculationNotification
	Event -> primitive -> transfer only exists
	and Event -> messageInformation -> sentBy = "DTCC"

isEvent CashTransfer <"The qualification of a cash transfer from the fact that the only component is a cashTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent
	and Event -> messageInformation -> sentBy <> "DTCC" // This is a kludge related to the CashflowCalculationNotification qualification

isEvent CashAndSecurityTransfer <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in the same direction.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transferorPartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

//isEvent ClearingAcceptance <"The acceptance of an alpha trade submission by a CCP.">
//	Event -> primitive -> inception exists
//	and Event -> primitive -> inception -> after -> clearingWorkflow -> clearingStatus = WorkflowEnum.Accepted
//	and Event -> primitive -> quantityChange exists
//	and quantityAfterQuantityChange = 0.0

// Alpha trade terminated, beta gamma initiated
//isEvent ClearingConfirmation <"The clearing confirmation event.">
//	Event -> primitive -> inception only exists
//	and Event -> primitive -> inception -> after -> clearingWorkflow -> clearingStatus = WorkflowEnum.Cleared
//	and Event -> lineage -> contractReference exists

isEvent ClearingRejection <"The rejection of an alpha trade submission by a CCP.">
	Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> clearingWorkflow -> clearingStatus = WorkflowEnum.Rejected

isEvent ClearingSubmission <"The submission of a contract to a CCP.">
	Event -> primitive -> inception only exists
	and Event -> primitive -> inception -> after -> clearingWorkflow -> clearingStatus = WorkflowEnum.Submitted
	and Event -> primitive -> inception -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization

isEvent AlphaTradeTermination <"The termination by the CCP of the alpha trade that was admitted to clearing.">
	Event -> primitive -> quantityChange only exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> before -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization
	and Event -> primitive -> quantityChange -> after -> contract -> partyRole -> role = PartyRoleEnum.ClearingOrganization

isEvent ClearingNotification <"The notification by the CCP of, respectively, the beta and the gamma trades that result from the clearing process.">
	Event -> primitive -> inception only exists
	and Event -> primitive -> inception -> after -> clearingWorkflow -> clearingStatus = WorkflowEnum.Cleared
	and Event -> lineage -> contractReference exists

//workflow rule ClearedContract
	// Event -> count = 3
	// and Event = AlphaTradeTermination count = 1
	// and Event = ClearingNotification count = 2
	// and economic terms are the same across the underlying contracts
	// and contractId are distinct among the contracts
	// and event date of alpha trade termination = trade date of the beta and gamma trades
	// and CCP which is in the party role of the alpha trade is the same as the CCP which is counterparty to the beta and gamma trades
	
isEvent Compression <"The qualification of a compression event from the fact that (i) the intent is Compression when specified, (ii) the quantity change primitive exists, (iii) and there are multiple contracts (or contract references) specified in the before state.">
	Event -> intent when present = IntentEnum.Compression
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> quantityChange -> before -> contract multiple exists

isEvent DerivedObservation <"The qualification of a derived observation event from the fact that (i) the only primitive is the observation, (ii) there are multiple instances of such observations, and (iii) there is an associated call function to compute, say, an interpolation.">
	Event -> primitive -> observation only multiple exists
	and Event -> functionCall exists

isEvent Exercise <"The qualification of an exercise event from the fact that (i) the intent is Exercise when specified, (ii) the only primitive is the quantityChange, and (iii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	Event -> intent when present = IntentEnum.Exercise
	and Event -> primitive -> exercise only exists

isEvent Increase <"The qualification of a increase event from the fact that (i) the intent is Increase when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract increases.">
	Event -> intent when present = IntentEnum.Increase
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange < quantityAfterQuantityChange
	and changedQuantity > 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

isEvent MultipleTransfers <"The qualification an event that combines multiple transfers from the fact that multiple transfer primitives exist.">
	Event -> primitive -> transfer multiple exists

isEvent NewTrade
	Event -> intent when present = IntentEnum.NewTrade
	and Event -> primitive -> inception only exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow is absent
	and Event -> primitive -> inception -> after -> clearingWorkflow is absent
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

isEvent Novation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the remaining quantity = 0, (iv) the closedState of the contract is Novated, (v) the stepped-in contract has a different contract identifier than the novated contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> intent when present = IntentEnum.Novation
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Novated
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
//	and originalContractParties <> newContractParties

alias novatedContractEffectiveDate
	Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate
	or Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate

alias originalContractParties
	( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

alias newContractParties
	( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> buyerSeller -> sellerPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> payerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> payerReceiver -> receiverPartyReference )
	or ( Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> buyerPartyReference
		and Event -> primitive -> inception -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> buyerSeller -> sellerPartyReference	)

isEvent Observation <"The qualification of an observation event from the fact that (i) the only primitive is the observation, and (ii) that there is only a single instance of such observation.">
	Event -> primitive -> observation only single exists

isEvent PartialNovation <"The qualification of a novation event from the fact that (i) the intent is Novation when specified, (ii) the primitives quantityChange and inception exist, (iii) the contract quantity/notional has decreased as part of the quantityChange primitive, while (iv) there is a remaining quantity/notional, (v) the stepped-in contract has a different contract identifier than the original contract, (vi) the stepped-in contract has the novation event date and the novation event effective date, and (vii) the contract counterparties have changed.">
	Event -> intent when present = IntentEnum.PartialNovation
	and Event -> primitive -> quantityChange exists
	and Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> contract -> contractIdentifier <> Event -> primitive -> quantityChange -> before -> contract -> contractIdentifier
	and Event -> eventDate = Event -> primitive -> inception -> after -> contract -> tradeDate -> date
	and Event -> effectiveDate = novatedContractEffectiveDate
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
//	and originalContractParties <> newContractParties

data rule Novation_fee <"Logic to specify that if a cash transfer is qualified as a novation fee, it must have lineage into multiple contracts and one single event (the novation event).">
	when Event -> primitive -> transfer -> cashTransfer -> cashflowType = CashflowTypeEnum.NovationFee
	then Event -> lineage -> contractReference multiple exists
		and Event -> lineage -> eventReference single exists

isEvent PartialTermination <"The qualification of a partial termination event from the fact that (i) the intent is Partial Termination when specified, (ii) the associated primitives are the quantityChange and the cash transfer, the (iii) the quantity associated with the contract decreases, and (iv) there is an actual remaining quantity.">
	Event -> intent when present = IntentEnum.PartialTermination
	and ( Event -> primitive -> quantityChange only exists
		or ( Event -> primitive -> quantityChange and Event -> primitive -> transfer -> cashTransfer ) exists )
	and quantityBeforeQuantityChange > quantityAfterQuantityChange
	and quantityAfterQuantityChange > 0.0
	and changedQuantity < 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState is absent

alias quantityBeforeQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	(Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue 
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> step -> stepValue
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount

alias quantityAfterQuantityChange <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">
	Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency )-> step -> stepValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount
	and ( Event -> primitive -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount

alias changedQuantity
	Event -> primitive -> quantityChange -> change -> quantity -> amount
	and Event -> primitive -> quantityChange -> change -> notionalAmount -> amount
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepSchedule -> initialValue
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepSchedule -> step -> stepValue
	and Event -> primitive -> quantityChange -> change -> notionalSchedule -> notionalStepParameters -> notionalStepAmount
	and Event -> primitive -> quantityChange -> change -> fxLinkedNotional -> initialValue

isEvent Payment <"The qualification of a payment event from the fact that the only primitive is the cash transfer.">
	Event -> primitive -> transfer -> cashTransfer only exists

isEvent Reset <"The qualification of a reset event from the fact that the only primitive is the reset.">
	Event -> primitive -> reset only exists

isEvent SecurityTransfer <"The qualification of a security transfer from the fact that the only component is a securityTransfer.">
	Event -> primitive -> transfer only exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer is absent
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent SecuritySettlement <"The qualification of a security settlement from the fact that (i) it is composed of a cashTransfer component and a securityTransfer component, and (ii) the cash and security move in opposite directions.">
	Event -> primitive -> transfer -> cashTransfer exists
	and Event -> primitive -> transfer -> securityTransfer exists
	and Event -> primitive -> transfer -> cashTransfer -> payerReceiver -> payerPartyReference = Event -> primitive -> transfer -> securityTransfer -> transferorTransferee -> transfereePartyReference
	and Event -> primitive -> transfer -> commodityTransfer is absent

isEvent Termination <"The qualification of a termination event from the fact that (i) the intent is Termination when specified, (ii) the only primitive is the quantityChange and there is only one such primitive involved, the (iii) the remaining quantity is null, and (iv) the closedState of the contract is Terminated.">
	Event -> intent when present = IntentEnum.Termination
	and Event -> primitive -> quantityChange only exists
	and quantityAfterQuantityChange = 0.0
	and Event -> primitive -> quantityChange -> after -> contract -> closedState -> state = ClosedStateEnum.Terminated

isEvent TradeWarehousePositionNotification
	Event -> primitive -> inception exists
	and Event -> primitive -> inception -> after -> tradeWarehouseWorkflow exists
	
/****************
 * Workflow rules
 */
	
/*
 * workflow rule ClearingProcess
 *	ClearingAcceptance precedes ClearingNotification
 *  Contract rosettaKey lineage
 */
	
