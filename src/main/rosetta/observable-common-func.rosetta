namespace cdm.observable.common
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*

func ResolveTimeZoneFromTimeType: <"Function to resolve a TimeType into a TimeZone based on a determination method.">
	inputs:
		timeType TimeTypeEnum (1..1)
		determinationMethod DeterminationMethodEnum (1..1)

	output:
		time TimeZone (1..1)

func PriceQuantityTriangulation:
	inputs:
		priceQuantity PriceQuantity (0..*)
		
	output:
		success boolean (1..1)

	assign-output success:
		if priceQuantity -> price -> priceType = PriceTypeEnum->CashPrice 

		then CashPriceQuantityNoOfUnitsTriangulation(priceQuantity)
		
			else True

func CashPriceQuantityNoOfUnitsTriangulation: <"Data rule to check the relationship between cash price, notional and number of units.">
    // TODO (HUGO) - is this still applicable?  How do we calc number of units?
	inputs:
		priceQuantity PriceQuantity (0..*)

	output:
		success boolean (1..1)

	alias notional:
		CurrencyAmount(priceQuantity, empty)

	alias noOfUnits:
		NoOfUnits(priceQuantity)

	alias cashPrices:
		priceQuantity -> price -> amount

	alias cashPrice:
		cashPrices only-element

	assign-output success:
		if (cashPrice and noOfUnits and notional) exists
		then cashPrice * noOfUnits = notional

/*
No longer necessary with new PQ design
func ExchangeRateQuantityTriangulation:
	inputs:
		priceNotation PriceNotation (0..*)
		quantityNotation QuantityNotation (0..*)

	output:
		success boolean (1..1)

	alias exchangeRates:
		priceNotation -> price -> exchangeRate

	alias exchangeRate:
		exchangeRates only-element

	alias rate:
		if exchangeRate -> rate exists
		then exchangeRate -> rate
		else exchangeRate -> spotRate

	alias quotedCurrency:
		exchangeRate -> quotedCurrencyPair

	alias quantity1:
		CurrencyAmount(quantityNotation, quotedCurrency -> currency1)

	alias quantity2:
		CurrencyAmount(quantityNotation, quotedCurrency -> currency2)

	assign-output success:
		if (quantity1 and quantity2 and rate) exists
		then
		if quotedCurrency -> quoteBasis = QuoteBasisEnum -> Currency1PerCurrency2
			then quantity1 / quantity2 = rate
			else if quotedCurrency -> quoteBasis = QuoteBasisEnum -> Currency2PerCurrency1
				then quantity2 / quantity1 = rate

*/

func NoOfUnits: <"Get quantity associated with product identifier.">
	inputs:
		priceQuantity PriceQuantity (0..*)

	output:
		noOfUnits number (1..1)


func CurrencyAmount: <"Get quantity associated with currency.">
	inputs:
		priceQuantity PriceQuantity (0..*)
		currency string (0..1)

	output:
		currencyAmount number (1..1)

// TODO: turn these functions into language level operators i.e. '+'
func Plus:
	inputs:
		q1 cdm.base.math.Quantity (1..1)
		q2 cdm.base.math.Quantity (1..1)
	output:
		result cdm.base.math.Quantity (1..1)

// TODO: turn these functions into language level operators i.e. '='
func Equals:
	// TODO Never referenced in CDM
	inputs:
		quantity cdm.base.math.Quantity (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

// TODO: turn these functions into language level operators i.e. '>'
func GreaterThan:
	inputs:
		quantity cdm.base.math.Quantity (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

// TODO: turn these functions into language level operators i.e. '>='
func GreaterThanEquals:
	// TODO Never referenced in CDM
	inputs:
		quantity cdm.base.math.Quantity (1..*)
		scalar number (1..1)
	output:
		result boolean (1..1)

func ExtractQuantityByAsset:
	inputs:
		priceQuantities PriceQuantity (1..*)
		observable Observable (1..1)
	output:
		priceQuantity PriceQuantity (1..1)

func ExtractQuantityByCurrency:
	inputs:
		priceQuantities PriceQuantity (1..*)
		currency string (1..1)
	output:
		priceQuantity PriceQuantity (1..1)


