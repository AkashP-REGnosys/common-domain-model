namespace cdm.security.lending
version "${project.version}"

import cdm.base.math.*
import cdm.base.datetime.*
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.asset.common.*

import cdm.observable.asset.*
import cdm.observable.common.*
import cdm.observable.event.*

import cdm.product.template.*
import cdm.product.asset.*
import cdm.product.common.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*

import cdm.legalagreement.contract.*
import cdm.legalagreement.common.*
import cdm.legalagreement.contract.*
import cdm.legalagreement.master.*

import cdm.event.workflow.*
import cdm.event.position.*
import cdm.event.common.*

func Create_SecurityLendingInvoice: <"Defines the process of calculating and creating a Security Lending Invoice.">

	inputs:
		instruction BillingInstruction (1..1) <"Specifies the instructions for creation of a Security Lending billing invoice.">

	output:
		invoice SecurityLendingInvoice (1..1) <"Produces the Security Lending Invoice">

	assign-output invoice->sendingParty:
		instruction->sendingParty

	assign-output invoice->receivingParty:
		instruction->receivingParty	

	assign-output invoice->billingStartDate:
		instruction->billingStartDate

	assign-output invoice->billingEndDate:
		instruction->billingEndDate

	assign-output invoice -> billingRecord:
		Create_BillingRecords (instruction -> billingRecordInstruction)

	assign-output invoice->billingSummary:
		Create_BillingSummary (invoice -> billingRecord)

func Create_BillingRecords: <"Creates for each billing instruction an individual billing record to be included in a Security Lending Billing Invoice">
	
	inputs:
		billingInstruction BillingRecordInstruction (1..*) <"Instruction for creating the billing records contained within the invoice">
	output:
		billingRecord BillingRecord (1..*)
	//loop

func Create_BillingRecord: <"Creates an individual billing record to be included in a Security Lending Billing Invoice">
	
	inputs:
		billingInstruction BillingRecordInstruction (1..1) <"Instruction for creating the billing records contained within the invoice">

	output:
		billingRecord BillingRecord (1..1) <"The billing record">

	alias tradeState: <"Creates a trade state with observations attached.">
		Create_SecurityFinanceTradeStateWithObservations (billingInstruction)

	alias billingAmount: <"Resolves the billing amount for the individual trade record.">
		ResolveSecurityFinanceBillingAmount (tradeState, tradeState -> resetHistory only-element, billingInstruction -> recordStartDate, billingInstruction -> recordEndDate, billingInstruction -> settlementDate)

	assign-output billingRecord -> recordStartDate:	
		billingInstruction -> recordStartDate

	assign-output billingRecord -> recordEndDate:	
		billingInstruction -> recordEndDate

	assign-output billingRecord -> tradeState:
		tradeState

	assign-output billingRecord -> recordTransfer:
		billingAmount


func Create_SecurityFinanceTradeStateWithObservations: <"Attaches a set of Observations to a Security Finance Transaction.">
	inputs:
		billingInstruction BillingRecordInstruction (1..1)

	output:
		tradeState TradeState (1..1)

	alias securityFinancePayout:
		billingInstruction -> tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element

	alias date:
		billingInstruction -> recordEndDate

	assign-output tradeState:
		billingInstruction -> tradeState

	assign-output tradeState -> resetHistory:
		Create_SecurityFinanceReset (securityFinancePayout, billingInstruction -> observation, date)

func Create_SecurityFinanceReset: <"Defines how to resolve the reset value for an equity payout.">
	inputs:
		securityFinancePayout SecurityFinancePayout (1..1) <"Represents the SecurityFinancePayout to which the reset will apply.">
		observation Observation (1..*) <"Represents the observations that will be used to compute the reset value.">
		resetDate date (1..1) <"Specifies the date of the reset.">

	output:
		reset Reset (1..1)

	assign-output reset -> resetValue: <"Assigns the observed value to the reset value. In the case of EquityPayout, the observed value represents the price of the underlying at the end of the period and no further manupulation of that value is required.">
		ResolveObservationAverage(observation)
		// work out the average as the value to be used in the calculation

	assign-output reset -> resetDate:
		resetDate

	assign-output reset -> observations: <"Assigns the observation required to compute the rest value as audit.">
		observation

	assign-output reset -> aggregationMethodology -> averagingCalculationMethod: AveragingCalculationMethodEnum -> Arithmetic

func ResolveObservationAverage: <"Specifies the interface that should be used by implementors to resolve a single observation when provided many, applying the averaging method, if one is provided.">
	inputs:
		observations Observation (1..*)

	output:
		resetValue Price (1..1)

	//java to calculate average

func ResolveSecurityFinanceBillingAmount: <"Calculates the billing amount for a Security Finance transaction.">
	inputs:
		tradeState TradeState (1..1)
		reset Reset (1..1)
		recordStartDate date (1..1)
		recordEndDate date (1..1)
		transferDate date (1..1)

	output:
		transfer Transfer (1..1)

	alias securityQuantity: <"Specifies the number of securities.">
		FilterQuantityByFinancialUnit( tradeState -> trade -> tradableProduct -> tradeLot -> priceQuantity -> quantity, FinancialUnitEnum -> Share)

	alias interestRatePayout: <"The interest payout that represents the lending fee.">
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element
	
	alias securityFinancePayout: <"The security finance payout that represents the securities lent.">
		tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout only-element

	alias valuationPercentage:
		(1/securityFinancePayout -> collateralProvisions -> marginPercentage -> valuationPercentage)

	alias marginRatio:
		if securityFinancePayout -> collateralProvisions -> marginPercentage -> valuationPercentage exists
			then valuationPercentage
		else if securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage exists
			then securityFinancePayout -> collateralProvisions -> marginPercentage -> marginPercentage
		else 1.0

	alias billingQuantity:
		Create_Quantity (reset -> resetValue -> amount * securityQuantity -> amount * marginRatio, empty)

	alias calculationPeriodRange: CalculationPeriodRange(recordStartDate, recordEndDate, empty)

	alias performance:
		if interestRatePayout -> rateSpecification -> fixedRate exists
		then FixedAmount(
			interestRatePayout,
			interestRatePayout -> rateSpecification -> fixedRate -> rateSchedule -> initialValue -> amount,
			billingQuantity,
			recordEndDate,
			calculationPeriodRange)
		else if interestRatePayout -> rateSpecification -> floatingRate exists
		then FloatingAmount(
			interestRatePayout,
			interestRatePayout -> rateSpecification -> floatingRate -> spreadSchedule only-element -> initialValue -> amount,
			reset only-element -> resetValue -> amount,
            billingQuantity,
			recordEndDate,
			calculationPeriodRange)

	assign-output transfer -> quantity -> amount:
		performance

	assign-output transfer -> quantity -> unitOfAmount -> currency:
        interestRatePayout -> payoutQuantity -> quantitySchedule -> initialQuantity -> unitOfAmount -> currency

	assign-output transfer -> payerReceiver -> payerPartyReference:
	    if performance >= 0 then interestRatePayout -> payerReceiver -> payerPartyReference else interestRatePayout -> payerReceiver -> receiverPartyReference

	assign-output transfer -> payerReceiver -> receiverPartyReference:
	    if performance >= 0 then interestRatePayout -> payerReceiver -> receiverPartyReference else interestRatePayout -> payerReceiver -> payerPartyReference

	assign-output transfer -> settlementDate -> adjustedDate:
		transferDate

func Create_BillingSummary: <"Creates a billing summary to be included in a Security Lending Billing Invoice.">

	inputs:
		billingRecord BillingRecord (1..*)

	output:
		billingSummary BillingSummary (1..1)

//sums all billing records and assigns value to billing summary
//sets enum to ParentTotal


func Create_Return: <"Defines the process of partially or fully returning a Security Lending Transaction.">
 	[creation BusinessEvent]

 	inputs:
 		tradeState TradeState (1..1) <"Specifies a previously formed contractual product with a Security Finance payout. It is required that the description of the contractual product be contained within the previous business event, i.e. its lineage must contain the formation of a contractual product.">
 		returnInstruction ReturnInstruction (1..1) <"Specifies the information required to fully return the Stock Loan in accordance with the economic terms of the contractual product.">
		returnDate date (1..1) <"Specifies the date of the full return.">

  	output:
 		returnEvent BusinessEvent (1..1) <"Produces the business event composed of primitive events describing the transfer and termination, as a result of the input return instruction.">

	alias tradableProduct:
			tradeState -> trade -> tradableProduct


	assign-output returnEvent -> primitives -> quantityChange: <"Creates a new contract within the quantity change primitive's after state equivalent to the new notional on the partially returned original contract, assuming there's a single security finance transaction in the original financial contract that is part returned.">
 		Create_QuantityChangePrimitive(
			tradeState,
		 	DeductAmountForEachMatchingQuantity(tradableProduct -> tradeLot -> priceQuantity -> quantity, returnInstruction -> quantity)
		)

	assign-output returnEvent -> eventDate:
		returnDate

func Create_PayerReceiver:
	inputs:
		payer CounterpartyRoleEnum (0..1)
		receiver CounterpartyRoleEnum (0..1)
	output:
		payerReceiver PayerReceiver (1..1)

	assign-output payerReceiver -> payer:
		payer

	assign-output payerReceiver -> receiver:
		receiver


func Qualify_FullReturn: <"The qualification of a full return event from the fact that (i) a quantityChange primitive and a transfer primitive exists, (ii) a securityFinancePayout exists, (iii) the remaining quantity = 0, and (iv) the closedState of the contract is Terminated.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	alias transfer: TransfersForDate( businessEvent -> primitives -> transfer -> after -> transferHistory, businessEvent -> eventDate ) -> transfers only-element
	assign-output is_event:
		(businessEvent -> intent is absent or businessEvent -> intent = IntentEnum -> Termination)
		and businessEvent -> primitives -> quantityChange -> after -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> securityFinancePayout exists
		and (businessEvent -> primitives count = 1
			and businessEvent -> primitives -> quantityChange exists
			or (businessEvent -> primitives -> quantityChange exists and transfer exists))
		and QuantityDecreasedToZero(businessEvent -> primitives -> quantityChange) = True
		and businessEvent -> primitives -> quantityChange -> after -> state -> closedState -> state <> ClosedStateEnum -> Terminated

func Qualify_Reallocation: <"The qualification of a reallocation event from the fact that (i) a quantity change primitive exists, (ii) a split primitive exists, and (iii) the intent is Reallocation.">
	[qualification BusinessEvent]
	inputs:
		businessEvent BusinessEvent(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		businessEvent -> primitives -> split count = 1
		and businessEvent -> primitives -> split -> before -> state -> closedState -> state = ClosedStateEnum -> Allocated
		and businessEvent -> primitives -> quantityChange exists
