namespace "org.isda.cdm"
version "${project.version}"

/***************************************************************
 * Aliases (other than those embedded in the calculation syntax)
 */
func ForwardFX:
	inputs: 
		forwardPayout ForwardPayout(1..1)
	output: result ForeignExchange (1..1)
	assign-output result: forwardPayout -> underlier -> singleUnderlier -> underlyingProduct -> foreignExchange

func EffectiveDate:
	inputs:
		economicTerms EconomicTerms(1..1)
	output: result ListOfDates(1..1)
	assign-output result -> dates: [
			economicTerms -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> effectiveDate -> relativeDate -> adjustedDate,
			economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> payout -> interestRatePayout only-element-> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate,
			economicTerms -> payout -> equityPayout only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			economicTerms -> payout -> equityPayout only-element-> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			economicTerms -> payout -> equityPayout only-element-> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate
	]

// TODO - Providing the ability to embed aliases would provide the ability to ensure consistency between this alias and the effectiveDate one, while also simplify the syntax
// See Trello card https://trello.com/c/89Lv8rAn
func NovatedContractEffectiveDate:
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: result ListOfDates(1..1)
	
	alias eTerms: workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> contractualProduct -> economicTerms
	alias effectiveDate: eTerms only-element -> effectiveDate
	alias interestRatePayoutDate: eTerms only-element-> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate
	alias equityPayoutDate: eTerms only-element-> payout -> equityPayout -> calculationPeriodDates -> effectiveDate
	
	assign-output result -> dates: [
			effectiveDate -> adjustableDate -> adjustedDate,
			effectiveDate -> adjustableDate -> unadjustedDate,
			effectiveDate -> relativeDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> adjustedDate,
			interestRatePayoutDate -> adjustableDate -> unadjustedDate,
			interestRatePayoutDate -> relativeDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> adjustedDate,
			equityPayoutDate -> adjustableDate -> unadjustedDate,
			equityPayoutDate -> relativeDate -> adjustedDate
	]

func PaymentDate: // Scope limited to interestPayout until such time that we position it to the economicTerms level
	inputs: economicTerms EconomicTerms(1..1)
	output: result date(0..1)
	assign-output result: economicTerms -> payout -> interestRatePayout only-element -> paymentDate -> adjustedDate


type ListOfDates:
	dates date(0..*)

type ListOfNumbers:
	numbers number(0..*)
	
	

func QuantityAfterQuantityChange: <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) after a quantity change primitive.">
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: result ListOfNumbers(1..1)
	alias notionalAmountGroup: empty
	assign-output result -> numbers: [
		workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency ) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> step -> stepValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> after -> contract -> contractualQuantity -> quantityNotation group by assetIdentifier -> currency ) -> quantity -> amount
	]

func QuantityBeforeQuantityChange: <"The alias to represent the quantity or notional amount in terms of number of units (i.e. ignoring the currency or units denomination) before a quantity change primitive.">
	inputs:
		workflowEvent WorkflowEvent(1..1)
	output: result ListOfNumbers(1..1)
	assign-output result -> numbers: [
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> quantity) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalAmount group by currency) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> initialValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule -> notionalStepSchedule group by currency ) -> step -> stepValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> notionalSchedule group by notionalStepSchedule -> currency ) -> notionalStepParameters -> notionalStepAmount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> interestRatePayout -> quantity -> fxLinkedNotional group by varyingNotionalCurrency ) -> initialValue,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> protectionTerms -> notionalAmount group by currency ) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualProduct -> economicTerms -> payout -> optionPayout -> quantity -> notionalAmount group by currency ) -> amount,
		( workflowEvent -> businessEvent -> primitives -> quantityChange -> before -> contract -> contractualQuantity -> quantityNotation group by assetIdentifier -> currency ) -> quantity -> amount
	]

//  FIXME create and use new Map built-i n type. See https://github.com/REGnosys/rosetta-dsl/issues/129
func ListsCompare:
	inputs:
		compareOp CompareOp(1..1)
		left ListOfNumbers (1..1)
		right ListOfNumbers(0..1)
		rightNumber number(0..1)
	output: result boolean (1..1)

enum CompareOp:
	Greater
	Equal

func TerminationDate: // Scope limited to interestPayout until such time that we position it to the economicTerms level
	inputs: economicTerms EconomicTerms(1..1)
	output: result ListOfDates(1..1)
	alias interestRateTerminationDate: economicTerms -> payout -> interestRatePayout only-element -> calculationPeriodDates -> terminationDate
	alias equityPayoutTerminationDate: economicTerms -> payout -> equityPayout only-element -> calculationPeriodDates -> terminationDate
	
	assign-output result -> dates:
		[
			economicTerms -> terminationDate -> adjustableDate -> adjustedDate,
			economicTerms -> terminationDate -> adjustableDate -> unadjustedDate,
			economicTerms -> terminationDate -> relativeDate -> adjustedDate,
			interestRateTerminationDate -> adjustableDate -> adjustedDate,
			interestRateTerminationDate -> adjustableDate -> unadjustedDate,
			interestRateTerminationDate -> relativeDate -> adjustedDate,
			equityPayoutTerminationDate -> adjustableDate -> adjustedDate,
			equityPayoutTerminationDate -> adjustableDate -> unadjustedDate,
			equityPayoutTerminationDate -> relativeDate -> adjustedDate
		]
