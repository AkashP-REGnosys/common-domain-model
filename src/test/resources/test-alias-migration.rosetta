namespace org.isda.cdm.test
version "${project.version}"

import org.isda.cdm.*

//isEvent TestPartialNovation <"">
//	WorkflowEvent -> effectiveDate = novatedContractEffectiveDate
//
//

func TestPartialNovationFunc: <"">
	inputs: wEvent WorkflowEvent (0..1)
	output: result boolean (0..1)
	assign-output result: NovatedContractEffectiveDate(wEvent) -> dates only-element = wEvent -> effectiveDate

func NovatedContractEffectiveDate2:

	inputs: workflowEvent WorkflowEvent(1..1)
	output: result ListOfDates(0..1)

	alias eTerms: workflowEvent -> businessEvent -> primitives -> inception -> after -> contract -> contractualProduct -> economicTerms

	assign-output result -> dates: [ 
			eTerms -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> effectiveDate -> relativeDate -> adjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> payout -> interestRatePayout -> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> adjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
			eTerms -> payout -> equityPayout -> calculationPeriodDates -> effectiveDate -> relativeDate -> adjustedDate
	]

func TestGroupBy:
	inputs:
		input1 TypeToGroup (0..1)
	output: out ListOfNumbers (1..1)
	assign-output out -> numbers: [
		(input1 -> manyAttr group by strAttr)-> numAttr 
	]
	

type TypeToGroup:
	boolAttr boolean (0..1)
	numAttr number (0..1)
	strAttr string (0..1)
	manyAttr TypeToGroup (1..*)

type Foo:
	bar Bar (0..*)
	bar2 Bar (0..*)
	baz Baz (0..1)

type Bar:
	before number (0..1)
	after number (0..1)

type Baz:
	bazValue number (0..1)
	other number (0..1)
	
func FeatureCallEqualToLiteral:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = 5

func FeatureCallEqualToFeatureCall:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = foo -> bar -> after

func FeatureCallsEqualToLiteralOr:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = 5 or foo -> baz -> other = 5

func FeatureCallListEqualToFeatureCall:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before = foo -> baz -> other

func FeatureCallListNotEqualToFeatureCall:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	assign-output is_event:
		foo -> bar -> before <> foo -> baz -> other
		
		
func MultipleOrFeatureCallsEqualToMultipleOrFeatureCalls:
	inputs: foo Foo(1..1)
	output: is_event boolean (1..1)
	alias values: [foo -> bar -> before, foo -> baz -> other]
	assign-output is_event:
		values contains foo -> bar -> after
		or values contains foo -> baz -> bazValue